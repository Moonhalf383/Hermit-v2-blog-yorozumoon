<!DOCTYPE html>
<html lang="zh-cn">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="UTF-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1, minimal-ui">
<meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="robots" content="index, follow"><meta name="author" content="Moonhalf">
<meta name="description" content=""><link rel="manifest" href="/site.webmanifest"><link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<meta name="apple-mobile-web-app-title" content="Yorozumoon" />
<meta name="theme-color" content="#494f5c">
<meta name="msapplication-TileColor" content="#494f5c">

  <meta itemprop="name" content="SEU程序设计复习02：远古老登">
  <meta itemprop="description" content="本篇要素： 指针 C风格字符串 C风格数组 基本算法 指针">
  <meta itemprop="datePublished" content="2026-01-19T00:00:00+00:00">
  <meta itemprop="dateModified" content="2026-01-19T00:00:00+00:00">
  <meta itemprop="wordCount" content="5293">
  <meta itemprop="keywords" content="Cpp,Blog,课内"><meta property="og:url" content="http://localhost:1313/zh-cn/posts/seu%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A002%E8%BF%9C%E5%8F%A4%E8%80%81%E7%99%BB/">
  <meta property="og:site_name" content="Yorozumoon">
  <meta property="og:title" content="SEU程序设计复习02：远古老登">
  <meta property="og:description" content="本篇要素： 指针 C风格字符串 C风格数组 基本算法 指针">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-19T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-19T00:00:00+00:00">
    <meta property="article:tag" content="Cpp">
    <meta property="article:tag" content="Blog">
    <meta property="article:tag" content="课内">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="SEU程序设计复习02：远古老登">
  <meta name="twitter:description" content="本篇要素： 指针 C风格字符串 C风格数组 基本算法 指针">

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "SEU程序设计复习02：远古老登",
    "name": "SEU程序设计复习02：远古老登",
    "description": "本篇要素： 指针 C风格字符串 C风格数组 基本算法 指针 ",
    "keywords": ["cpp", "blog", "课内"],
    "articleBody": "本篇要素： 指针 C风格字符串 C风格数组 基本算法 指针 众所周知，无论是什么程序语言，程序运行时的数据都缓存在内存上。内存就像一张超级大的草稿纸。对于机器来说，除了对内存写入的数据本身外，数据写入的位置同样重要。知道了数据写入的位置，我们才能随时利用我们写入的数据进行计算。\n于是指针诞生了。如果说一般的变量是用来存储有价值的数据本身，指针的作用则是存储这些变量的内存地址，方便我们随时随地的调用这些变量。指针的本质仍然是变量，只不过它存储的内容是一个长十六进制的内存地址。\n我们来举一个简单的例子：\n#include int main(int argc, char *argv[]) { int x = 114514; int *y = \u0026x; std::cout \u003c\u003c y \u003c\u003c std::endl; std::cout \u003c\u003c *y \u003c\u003c std::endl; return 0; } 输出结果：\n0x7fc7cf03ac 114514 其中第一个输出结果就是这个指针指向的变量的地址，而第二个输出结果则是这个变量的值。事实上，*y可以看做是x的一个别名，两者的行为完全一致，因为他们都是同一个地址上相同数据类型的变量。你可以给*y赋值，x的值就会被同步改变，因为在内存上它们的意义是相同的。\n由于内存可以表示为一个长十六进制整数，所以自然我们对一个已知的内存进行加减就可以访问到它周围的数据。访问一个内存附近的元素有两种办法：直接对指针做加法，或者给指针追加下标：\n#include int main(int argc, char *argv[]) { int x = 114514; int *y = \u0026x; *(y + 1) = 191981; std::cout \u003c\u003c y \u003c\u003c std::endl; std::cout \u003c\u003c *y \u003c\u003c std::endl; std::cout \u003c\u003c y[1] \u003c\u003c std::endl; return 0; } 其中，*(y+1)访问y的内存的后一位并将其赋值为191981。在整个程序中，我们没有任何一个变量直接代表这个内存地址，我们是通过解引用的方式间接地访问到了这个地址。之后在输出阶段，我们调用y[1]同样表示的是y的内存的下一位的内容，所以理论上输出结果也应该是191981。\n输出结果如下，符合预期：\n0x7fd11438cc 114514 191981 这时候你会发现下标运算符似乎和数组中指定访问某个元素使用的操作符都是中括号。事实上，在C语言以及C++中，数组和指针在行为上确实非常类似，但是从根本上看两者是完全不同的东西。后面会提到。\n接下来是比较八股的部分，在实际的C++编程中没有人类会这么写，但是出题人会。\nint *a, b，这个语句中a是指针，b则是一个普通的变量。没有为什么，硬要理解的话*a和b都是int类型的变量。 int *p[4]表示的是一个数组，每个元素为一个*int指针。 int (*p)[4]表示的是一个数组，但是每个元素都是int数据。 直接看这个是没用的，真正要尝试理解这种设计，我们必须要站在老登语言C语言的角度看待问题。\n如何站在C语言老登的视角看待指针 在C语言中几乎没有高级的数据结构，最高级的数据结构就是结构体和原始数组了。这时候处理问题就不得不直面手动内存管理的问题。\nC语言一个最恶心的点在于，C语言有意识的在鼓励指针和数组之间的混淆。比如，很多时候指针和数组名的表现完全一致，甚至在将数组传参进入一个函数的时候完全就是指针。但是问题在于，数组和指针的底层实现完全不一致。\n比如在下面这个例子中：\n#include int main(int argc, char *argv[]) { int a[4] = {1, 2, 3, 4}; int *p = a; printf(\"%d\\n\", p[1]); return 0; } a是一个数组，p是一个指针，int *p = a之后p和a看起来指向的都是一个值，但是在底层上：\np是一个变量，它自身有一个地址，而地址上存储的是数组第一个元素的地址。 a是一个别名。a没有地址，a就是这个数组第一个元素地址的别名。 而对于一个常量指针，比如某个int * const q = a，它又有另一重底层意义：\nq是一个常量，但是它有自己的地址，它的地址上存储的数据是数组的第一个元素的地址。 这就意味着数组和指针是完全不同的数据类型。a虽然可以隐式退化为指针，原因完全是因为他们的意义基本一致，但是这不代表它们是同一个东西。\n同样，二维数组和二级指针根本上也不是一个东西。当我们写int a[3][4]时，a的类型是一个二维数组，当我们通过a[1][1]来访问元素的时候，C语言的底层实现方法不是通过指针进行间接访问，而是直接由下标计算偏移量。但是对于一个二级指针，我们可以让这个二级指针指向一个一级指针数组，再让一级指针指向一维数组，但是当我们想要访问元素时，底层的汇编指令是：先访问二级指针的地址，读取二级指针的存储的地址，再由这个地址加上偏移量访问一级指针，再由一级存储的地址加上偏移量访问元素。\n所以，虽然你可以造出一个和二维数组行为完全一致的二级指针，但是归根结底它们是完全不同的两个东西。回到我们原本的问题，我们来重新的明确阐述一下我们原本想讨论的问题：\n已知：\nint a[3]是一个数组 int* p是一个指针 问： int* p[3]是什么？ int (*p)[3]是什么？ 其实这个问题的根本就在于：凭什么int (*p)[3]的写法是合法的？\n比如，我们绝对不会写int (x+1) = 2然后希望x = 1。如果你在代码中这么写，那么你会喜提报错。但是int (*p)[3]却是合法的，它成功定义了一个变量，并且它的名字就是p。真正的诡异之处就在这里。\n假如我们把int*看做一个整体，表示后面的东西是一个指针，那么int* p[3]是容易理解的，它代表的就是一个存放了一级指针的指针数组。但是在int (*p)[3]里，我们会觉得中间的*p放在这里是不讲道理的，因为我们理应认为这个地方不应该进行任何的计算操作，而*p表示的是对p解引用。\n问题的答案是，C语言不是现代语言，而是远古老登。现代语言中我们会希望类型和标识符做到完全区分，而C语言的设计者遵循的原则是：声明的样子和使用时的样子应该完全一致。虽然我觉得这样也是不太讲道理的，但是对于理解这个问题意外的好用。\n比如，在int (*p)[3]定义后，本质上说明了一件事情：假如我想使用p寻找某个元素，我就应该写(*p)[i]来做到这件事，即：对p进行一个(*p)[i]的操作后，得到的应该是一个整数。\n那么，(*p)进行一个下标索引的操作后，得到的是一个整数，这就意味着(*p)本质上是一个数组，p的本质就是一个指针。对p解引用得到数组，就意味着p指针的基本类型就是数组。而p++就是下一个位置的数组，因此p和一个二维数组的行为是一致的，它们都可以表示连续内存中的一系列一维数组。此处的p叫做数组指针。\n而同样的，假如我们要去理解int *p[3]，我们就会知道如果我们要使用p来找到某个元素，我们就会写*p[3]，而我们知道下标索引的优先级高于解引用，这就意味着p[3]得到的是一个指针，所以p的本质是一个数组，内部的元素是指针。此处的p叫做指针数组。\n常量指针\u0026指针常量 常量指针：\nint a = 10; int b = 20; const int* p = \u0026a; 之后你可以使用p = \u0026b来修改p的指向，但是不能使用*p = 30来修改对应的值。\n指针常量：\nint a = 10; int b = 20; int* const p = \u0026a; 可以通过*p = 30来修改值，但是不能改变指向的地址。\nC风格数组 当我们将C风格数组作为参数传入函数时，数组名会退化为指针。这里就是完全意义上变为指针。\n比如，当我们写：void func(int arr[10]){...}的时候，我们就等同于写void func(int* arr)。虽然我们前文中提到数组和指针是完全不同的两种东西，但是这里，数组退化为指针的事情就是真实地发生了。\n这样的退化带来的第一个问题就是，我们没办法使用sizeof来获取一个数组的长度。最传统的做法就是添加一个参数来手动传入数组大小。\nC风格数组传参时，以下写法是完全等价的。\nvoid f(int arr[]); void f(int arr[10]); void f(int* arr); 等价的原因就在于无论原本是什么东西，在这里全部都会退化为指针。\n但是假如我们需要传入一个多维数组，比如某个int a[3][4]，此时我们就不能写f(a)，原因在我们前面分析指针原则的时候其实涉及到了，程序员有各种各样的方式实现多维数组，所以多维数组没办法直接退化为某个指针。\n以二维数组为例，原教旨主义的二维数组就是数组，内存连续。和它的行为最接近的是数组指针，所以传参时可以这么写：\nvoid foo(int (*a)[4]); 此外，如果确定了列数，你也可以这么写：\nvoid foo(int a[][4]); 但是不能这么写：\nvoid foo(int a[][]); C风格字符串 char s1[] = \"hello\"; 等价于：\nchar s1[] = {'h','e','l','l','o','\\0'}; 注意，\\0标志一个字符串结束。\n例子：\n#include int main(int argc, char *argv[]) { char str[] = \"Helloworld!\"; std::cout \u003c\u003c str \u003c\u003c std::endl; char str1[] = {'H', 'e', 'l', 'l', 'o', '\\0'}; std::cout \u003c\u003c str1 \u003c\u003c std::endl; char str2[] = {'H', 'e', '\\0', 'l', 'l', 'o'}; std::cout \u003c\u003c str2 \u003c\u003c std::endl; return 0; } 输出结果：\nHelloworld! Hello He 基本算法 在工程实践中，手写排序是被严格禁止的，因为你几乎不可能写的比标准库更好。但是对于考试只能说是不得不品的一环。\n冒泡排序 最佳实现：\n#include #include template\u003ctypename T\u003e void bubbleSort(std::vector\u003cT\u003e\u0026 arr) { int n = arr.size(); bool swapped; for (int i = 0; i \u003c n - 1; ++i) { swapped = false; for (int j = 0; j \u003c n - i - 1; ++j) { if (arr[j] \u003e arr[j + 1]) { std::swap(arr[j], arr[j + 1]); swapped = true; } } // 如果没有发生交换，直接跳出循环 if (!swapped) break; } } 基本原理就是进行多次迭代，每次都遍历一遍，如果某个位置前一个数字大于后一个，就将其交换；如果某次迭代的遍历过程中没有进行任何交换，就证明已经完成了从小到大的排序，可以结束计算了。\n我们也可以使用原始数组来重写一遍：\n#include void bubbleSort(int arr[], int len) { bool swapped = true; for (int i = 0; i \u003c len - 1 \u0026\u0026 swapped; i++) { swapped = false; for (int j = 0; j \u003c len - 1 - i; j++) { if (arr[j] \u003e arr[j + 1]) { int temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; swapped = true; } } } } int main(int argc, char *argv[]) { int arr[10] = {4, 1, 2, 6, 8, 4, 2, 5, 7, 3}; bubbleSort(arr, 10); for (int i = 0; i \u003c 10; i++) { std::cout \u003c\u003c arr[i] \u003c\u003c std::endl; } return 0; } 选择排序 template\u003ctypename T\u003e void selectionSort(std::vector\u003cT\u003e\u0026 arr) { int n = arr.size(); for (int i = 0; i \u003c n - 1; ++i) { int minIndex = i; for (int j = i + 1; j \u003c n; ++j) { if (arr[j] \u003c arr[minIndex]) { minIndex = j; } } if (minIndex != i) { std::swap(arr[i], arr[minIndex]); } } } 原理是每次遍历后把遍历涉及的元素中最小的元素移到前面，之后的遍历不再关注前面的元素。时间复杂度和冒泡排序一致。（但是冒泡排序更方便设定排序规则，所以我更喜欢冒泡排序。）\n同样使用原始数组实现一遍：\n#include void selectionSort(int arr[], int len) { for (int i = 0; i \u003c len; i++) { int minIndex = i; for (int j = i; j \u003c len; j++) { if (arr[j] \u003c arr[minIndex]) { minIndex = j; } } int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } } int main(int argc, char *argv[]) { int arr[10] = {4, 1, 5, 2, 6, 3, 7, 9, 8, 0}; selectionSort(arr, 10); for (int i = 0; i \u003c 10; i++) { std::cout \u003c\u003c arr[i] \u003c\u003c std::endl; } return 0; } 快速排序 template\u003ctypename T\u003e int partition(std::vector\u003cT\u003e\u0026 arr, int low, int high) { // 优化：三数取中选基准 int mid = low + (high - low) / 2; if (arr[mid] \u003c arr[low]) std::swap(arr[mid], arr[low]); if (arr[high] \u003c arr[low]) std::swap(arr[high], arr[low]); if (arr[high] \u003c arr[mid]) std::swap(arr[high], arr[mid]); T pivot = arr[mid]; int i = low - 1; int j = high + 1; while (true) { do { i++; } while (arr[i] \u003c pivot); do { j--; } while (arr[j] \u003e pivot); if (i \u003e= j) return j; std::swap(arr[i], arr[j]); } } template\u003ctypename T\u003e void quickSort(std::vector\u003cT\u003e\u0026 arr, int low, int high) { if (low \u003c high) { int p = partition(arr, low, high); quickSort(arr, low, p); quickSort(arr, p + 1, high); } } // 辅助调用接口 template\u003ctypename T\u003e void quickSort(std::vector\u003cT\u003e\u0026 arr) { if (!arr.empty()) { quickSort(arr, 0, arr.size() - 1); } } 顾名思义，快速排序算法确实非常快。冒泡排序和选择排序的速度都是$O(n^2)$，而快速排序的时间复杂度则是$O(n\\log n)$。我们来尝试理解下它的工作原理。\n快速排序的基本思想是：每次从一个分区中选取一个基准值，比它大的数字全部移动到右边，比它小的全部移动到左边，以交换过程最后的临界点作为分区界线形成了两个分区，之后再在这两个分区中重复这个过程。这样，每次进行分区就意味着一个数字找到了正确的位置，而分区量呈指数级增长，每次分区计算的用时和总数成正比，故时间复杂度为$O(n\\log n)$。\n在上面这段代码中，选取基准值的方法是在一个分区的最左、最右和最中间的三个元素中选出中间的那个数字，然后动用两个指针向基准值收缩，实现分区，之后再通过递归完成整体的排序。\n原始数组实现：\n#include void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } int partition(int arr[], int low, int high) { int mid = low + (high - low) / 2; if (arr[mid] \u003c arr[low]) swap(arr + mid, arr + low); if (arr[high] \u003c arr[low]) swap(arr + high, arr + low); if (arr[high] \u003c arr[mid]) swap(arr + high, arr + mid); int pivot = arr[mid]; int i = low - 1; int j = high + 1; while (true) { do { i++; } while (arr[i] \u003c arr[mid]); do { j--; } while (arr[j] \u003e arr[mid]); if (i \u003e= j) return j; swap(arr + i, arr + j); } } void quickSort(int arr[], int low, int high) { if (low \u003c high) { int p = partition(arr, low, high); quickSort(arr, low, p); quickSort(arr, low + 1, high); } } int main(int argc, char *argv[]) { int arr[10] = {4, 1, 5, 2, 6, 3, 7, 8, 9, 0}; quickSort(arr, 0, 9); for (int i = 0; i \u003c 10; i++) { std::cout \u003c\u003c arr[i] \u003c\u003c std::endl; } return 0; } 线性查找 从头到尾依次查找最符合条件的元素。就像苏格拉底最大的麦穗的寓言故事。\n懒得写了。\n二分查找 假如你要查找的元素总体是按照从小到大或者从大到小的顺序排列的，那么如果你要找到某个元素的位置就不需要把所有元素都搜一遍。我们只需要每次找到最中间的点，之后如果目标比中值大，则向右寻找，否则想左寻找。这样时间复杂度就大大减少。\n以下提供一种基于递归的解法：\n#include #include #include #include #include int arr[10]; //这一部分是搜索算法。 int binarySearch(const int arr[], int low, int high, int target) { if (low \u003e high) return -1; int mid = low + (high - low) / 2; if (target == arr[mid]) return mid; if (target \u003c arr[mid]) return binarySearch(arr, low, mid - 1, target); return binarySearch(arr, mid + 1, high, target); } void renewArray() { for (int i = 0; i \u003c sizeof(arr) / sizeof(int); i++) { arr[i] = rand() % 100 + 1; } std::sort(arr, arr + 9); //注意，这里需要进行排序，原因是二分查找只能适用于已经排序的数组。 } int main(int argc, char *argv[]) { std::srand(time(nullptr)); std::cout \u003c\u003c std::left; for (int i = 0; i \u003c 20; i++) { renewArray(); for (int j = 0; j \u003c 10; j++) { std::cout \u003c\u003c std::setw(8) \u003c\u003c arr[j]; } std::cout \u003c\u003c std::endl \u003c\u003c \"Index: \" \u003c\u003c binartSearch(arr, 0, 9, 50) \u003c\u003c std::endl; } return 0; } 然而，虽然说着容易，实际实践的时候经常会出现内存越界和死循环的问题。原因是分区的边界情况非常的不好考虑。以下罗列两种公认的最优写法。\n第一种被称为“经典精确查找”，做了很多防范问题的措施。\n#include template\u003ctypename T\u003e int binarySearch(const std::vector\u003cT\u003e\u0026 nums, T target) { int left = 0; int right = nums.size() - 1; // [left, right] 闭区间 while (left \u003c= right) { // 防止溢出的写法，等同于 (left + right) / 2 int mid = left + (high - low) / 2; if (nums[mid] == target) { return mid; // 找到了 } else if (nums[mid] \u003c target) { left = mid + 1; // 目标在右半部分 } else { right = mid - 1; // 目标在左半部分 } } return -1; // 未找到 } 另一种是所谓的“寻找边界写法”，在有目标值的时候返回符合的值中第一个目标的索引值，如果没有则返回第一个大于目标值的位置。\ntemplate\u003ctypename T\u003e int lowerBound(const std::vector\u003cT\u003e\u0026 nums, T target) { int left = 0; int right = nums.size(); // [left, right) 左闭右开区间 while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { // 当 nums[mid] \u003e= target 时，收缩右边界 // 这样会不断向左逼近第一个等于 target 的位置 right = mid; } } return left; // 此时 left == right } 最大公因数 int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } 原理是$gcd(a,b) = gcd(b,a\\%b)$。\n",
    "wordCount" : "5293",
    "inLanguage": "zh-cn",
    "datePublished": "2026-01-19T00:00:00Z",
    "dateModified": "2026-01-19T00:00:00Z",
    "author":{
        "@type": "Person",
        "name": "Moonhalf",
        "url": "http://localhost:1313/zh-cn/%E6%9C%88%E3%81%AE%E3%81%BE%E3%81%AB%E3%81%BE%E3%81%AB/"
        },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http://localhost:1313/zh-cn/posts/seu%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A002%E8%BF%9C%E5%8F%A4%E8%80%81%E7%99%BB/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Yorozumoon",
      "description": "",
      "logo": {
        "@type": "ImageObject",
        "url": "http://localhost:1313/favicon.ico"
      }
    }
}
</script><title>SEU程序设计复习02：远古老登</title><link rel="stylesheet dns-prefetch preconnect preload prefetch" as="style" media="screen" href="http://localhost:1313/css/style.min.7c4faf57019635cba7aa1b7c6581baeb1ec040f9c7d861be87c059d42585582c.css" integrity="sha256-fE+vVwGWNcunqht8ZYG66x7AQPnH2GG+h8BZ1CWFWCw=" crossorigin="anonymous">
	</head>

<body id="page">
<header id="site-header" class="animated slideInUp">
	<div class="hdr-wrapper section-inner">
		<div class="hdr-left">
			<div class="site-branding">
				<a href="http://localhost:1313/">Yorozumoon</a>
			</div>
			<nav class="site-nav hide-in-mobile"><a href="http://localhost:1313/zh-cn/posts/">文章</a><a href="http://localhost:1313/zh-cn/tags/">标签</a><a href="http://localhost:1313/zh-cn/about/">关于</a><a href="http://localhost:1313/zh-cn/links/">友链</a></nav>
		</div>
		<div class="hdr-right hdr-icons">
			<button id="toc-btn" class="hdr-btn desktop-only-ib" title="Table Of Contents"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list">
      <line x1="8" y1="6" x2="21" y2="6"></line>
      <line x1="8" y1="12" x2="21" y2="12"></line>
      <line x1="8" y1="18" x2="21" y2="18"></line>
      <line x1="3" y1="6" x2="3" y2="6"></line>
      <line x1="3" y1="12" x2="3" y2="12"></line>
      <line x1="3" y1="18" x2="3" y2="18"></line>
   </svg></button><span class="hdr-links hide-in-mobile"><a href="https://github.com/Moonhalf383" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
   stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
   <path
      d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
   </path>
</svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
   </svg></button>
		</div>
	</div>
</header>
<div id="mobile-menu" class="animated fast">
	<ul>
		<li><a href="http://localhost:1313/zh-cn/posts/">文章</a></li>
		<li><a href="http://localhost:1313/zh-cn/tags/">标签</a></li>
		<li><a href="http://localhost:1313/zh-cn/about/">关于</a></li>
		<li><a href="http://localhost:1313/zh-cn/links/">友链</a></li>
	</ul>
</div>

	<main class="site-main section-inner animated fadeIn faster"><article class="thin">
			<header class="post-header">
				<div class="post-date"><span>Jan 19, 2026</span></div>
				<h1>SEU程序设计复习02：远古老登</h1>
			</header>
			<div class="post-description"><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
   stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-feather">
   <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
   <line x1="16" y1="8" x2="2" y2="22"></line>
   <line x1="17.5" y1="15" x2="9" y2="15"></line>
</svg><a href="http://localhost:1313/zh-cn/%E6%9C%88%E3%81%AE%E3%81%BE%E3%81%AB%E3%81%BE%E3%81%AB/" target="_blank">Moonhalf</a></p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon">
      <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
      <line x1="7" y1="7" x2="7" y2="7"></line>
   </svg><span class="tag"><a href="http://localhost:1313/zh-cn/tags/cpp">cpp</a></span><span class="tag"><a href="http://localhost:1313/zh-cn/tags/blog">blog</a></span><span class="tag"><a href="http://localhost:1313/zh-cn/tags/%E8%AF%BE%E5%86%85">课内</a></span></p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
      <polyline points="14 2 14 8 20 8"></polyline>
      <line x1="16" y1="13" x2="8" y2="13"></line>
      <line x1="16" y1="17" x2="8" y2="17"></line>
      <polyline points="10 9 9 9 8 9"></polyline>
   </svg>5293&nbspWords 阅读时长24 Minutes, 3 Seconds</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
      <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
      <line x1="16" y1="2" x2="16" y2="6"></line>
      <line x1="8" y1="2" x2="8" y2="6"></line>
      <line x1="3" y1="10" x2="21" y2="10"></line>
   </svg>2026-01-19 00:00 &#43;0000
</p></div>
			<hr class="post-end">
			<div class="content">
				 <h1 id="本篇要素">本篇要素：<a href="#%e6%9c%ac%e7%af%87%e8%a6%81%e7%b4%a0" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h1>
<ul>
<li>指针</li>
<li>C风格字符串</li>
<li>C风格数组</li>
<li>基本算法</li>
</ul>
<h1 id="指针">指针<a href="#%e6%8c%87%e9%92%88" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h1>
<p><img src="/zh-cn/posts/seu%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A002%E8%BF%9C%E5%8F%A4%E8%80%81%E7%99%BB/SEU%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A002%E8%BF%9C%E5%8F%A4%E8%80%81%E7%99%BB-20260119-1.png" alt=""></p>
<p>众所周知，无论是什么程序语言，程序运行时的数据都缓存在内存上。内存就像一张超级大的草稿纸。对于机器来说，除了对内存写入的数据本身外，数据写入的位置同样重要。知道了数据写入的位置，我们才能随时利用我们写入的数据进行计算。</p>
<p>于是指针诞生了。如果说一般的变量是用来存储有价值的数据本身，指针的作用则是存储这些变量的内存地址，方便我们随时随地的调用这些变量。指针的本质仍然是变量，只不过它存储的内容是一个长十六进制的内存地址。</p>
<p>我们来举一个简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">114514</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>y <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> y <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>y <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>0x7fc7cf03ac
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">114514</span>
</span></span></code></pre></div><p>其中第一个输出结果就是这个指针指向的变量的地址，而第二个输出结果则是这个变量的值。事实上，<code>*y</code>可以看做是x的一个别名，两者的行为完全一致，因为他们都是同一个地址上相同数据类型的变量。你可以给<code>*y</code>赋值，<code>x</code>的值就会被同步改变，因为在内存上它们的意义是相同的。</p>
<p>由于内存可以表示为一个长十六进制整数，所以自然我们对一个已知的内存进行加减就可以访问到它周围的数据。访问一个内存附近的元素有两种办法：直接对指针做加法，或者给指针追加下标：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">114514</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>y <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>(y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">191981</span>;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> y <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>y <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> y[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中，<code>*(y+1)</code>访问y的内存的后一位并将其赋值为<code>191981</code>。在整个程序中，我们没有任何一个变量直接代表这个内存地址，我们是通过解引用的方式间接地访问到了这个地址。之后在输出阶段，我们调用<code>y[1]</code>同样表示的是y的内存的下一位的内容，所以理论上输出结果也应该是<code>191981</code>。</p>
<p>输出结果如下，符合预期：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>0x7fd11438cc
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">114514</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">191981</span>
</span></span></code></pre></div><p>这时候你会发现下标运算符似乎和数组中指定访问某个元素使用的操作符都是中括号。事实上，在C语言以及C++中，数组和指针在行为上确实非常类似，但是从根本上看两者是完全不同的东西。后面会提到。</p>
<p>接下来是比较八股的部分，在实际的C++编程中没有人类会这么写，但是出题人会。</p>
<ul>
<li><code>int *a, b</code>，这个语句中a是指针，b则是一个普通的变量。没有为什么，硬要理解的话<code>*a</code>和<code>b</code>都是int类型的变量。</li>
<li><code>int *p[4]</code>表示的是一个数组，每个元素为一个<code>*int</code>指针。</li>
<li><code>int (*p)[4]</code>表示的是一个数组，但是每个元素都是int数据。</li>
</ul>
<p>直接看这个是没用的，真正要尝试理解这种设计，我们必须要站在老登语言C语言的角度看待问题。</p>
<h2 id="如何站在c语言老登的视角看待指针">如何站在C语言老登的视角看待指针<a href="#%e5%a6%82%e4%bd%95%e7%ab%99%e5%9c%a8c%e8%af%ad%e8%a8%80%e8%80%81%e7%99%bb%e7%9a%84%e8%a7%86%e8%a7%92%e7%9c%8b%e5%be%85%e6%8c%87%e9%92%88" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>在C语言中几乎没有高级的数据结构，最高级的数据结构就是结构体和原始数组了。这时候处理问题就不得不直面手动内存管理的问题。</p>
<p>C语言一个最恶心的点在于，C语言有意识的在鼓励指针和数组之间的混淆。比如，很多时候指针和数组名的表现完全一致，甚至在将数组传参进入一个函数的时候完全就是指针。但是问题在于，数组和指针的底层实现完全不一致。</p>
<p>比如在下面这个例子中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>};
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, p[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>a是一个数组，p是一个指针，<code>int *p = a</code>之后p和a看起来指向的都是一个值，但是在底层上：</p>
<ul>
<li>p是一个变量，它自身有一个地址，而地址上存储的是数组第一个元素的地址。</li>
<li>a是一个<strong>别名</strong>。a没有地址，a就是这个数组第一个元素地址的别名。</li>
</ul>
<p>而对于一个常量指针，比如某个<code>int * const q = a</code>，它又有另一重底层意义：</p>
<ul>
<li>q是一个常量，但是它有自己的地址，它的地址上存储的数据是数组的第一个元素的地址。</li>
</ul>
<p>这就意味着数组和指针是完全不同的数据类型。a虽然可以隐式退化为指针，原因完全是因为他们的意义基本一致，但是这不代表它们是同一个东西。</p>
<p>同样，二维数组和二级指针根本上也不是一个东西。当我们写<code>int a[3][4]</code>时，a的类型是一个二维数组，当我们通过<code>a[1][1]</code>来访问元素的时候，C语言的底层实现方法不是通过指针进行间接访问，而是直接由下标计算偏移量。但是对于一个二级指针，我们可以让这个二级指针指向一个一级指针数组，再让一级指针指向一维数组，但是当我们想要访问元素时，底层的汇编指令是：先访问二级指针的地址，读取二级指针的存储的地址，再由这个地址加上偏移量访问一级指针，再由一级存储的地址加上偏移量访问元素。</p>
<p>所以，虽然你可以造出一个和二维数组行为完全一致的二级指针，但是归根结底它们是完全不同的两个东西。回到我们原本的问题，我们来重新的明确阐述一下我们原本想讨论的问题：</p>
<p>已知：</p>
<ul>
<li><code>int a[3]</code>是一个数组</li>
<li><code>int* p</code>是一个指针
问：</li>
<li><code>int* p[3]</code>是什么？</li>
<li><code>int (*p)[3]</code>是什么？</li>
</ul>
<p>其实这个问题的根本就在于：凭什么<code>int (*p)[3]</code>的写法是<strong>合法的</strong>？</p>
<p>比如，我们绝对不会写<code>int (x+1) = 2</code>然后希望x = 1。如果你在代码中这么写，那么你会喜提报错。但是<code>int (*p)[3]</code>却是合法的，它成功定义了一个变量，并且它的名字就是p。真正的诡异之处就在这里。</p>
<p>假如我们把<code>int*</code>看做一个整体，表示后面的东西是一个指针，那么<code>int* p[3]</code>是容易理解的，它代表的就是一个存放了一级指针的指针数组。但是在<code>int (*p)[3]</code>里，我们会觉得中间的<code>*p</code>放在这里是不讲道理的，因为我们理应认为这个地方不应该进行任何的计算操作，而*p表示的是对p解引用。</p>
<p>问题的答案是，C语言不是现代语言，而是远古老登。现代语言中我们会希望类型和标识符做到完全区分，而C语言的设计者遵循的原则是：声明的样子和使用时的样子应该完全一致。虽然我觉得这样也是不太讲道理的，但是对于理解这个问题意外的好用。</p>
<p>比如，在<code>int (*p)[3]</code>定义后，本质上说明了一件事情：假如我想使用p寻找某个元素，我就应该写<code>(*p)[i]</code>来做到这件事，即：对p进行一个<code>(*p)[i]</code>的操作后，得到的应该是一个整数。</p>
<p>那么，<code>(*p)</code>进行一个下标索引的操作后，得到的是一个整数，这就意味着<code>(*p)</code>本质上是一个数组，<code>p</code>的本质就是一个指针。对p解引用得到数组，就意味着p指针的基本类型就是数组。而p++就是下一个位置的数组，因此p和一个二维数组的行为是一致的，它们都可以表示连续内存中的一系列一维数组。此处的p叫做<strong>数组指针</strong>。</p>
<p>而同样的，假如我们要去理解<code>int *p[3]</code>，我们就会知道如果我们要使用p来找到某个元素，我们就会写<code>*p[3]</code>，而我们知道下标索引的优先级高于解引用，这就意味着<code>p[3]</code>得到的是一个指针，所以<code>p</code>的本质是一个数组，内部的元素是指针。此处的p叫做<strong>指针数组</strong>。</p>
<h3 id="常量指针指针常量">常量指针&amp;指针常量<a href="#%e5%b8%b8%e9%87%8f%e6%8c%87%e9%92%88%e6%8c%87%e9%92%88%e5%b8%b8%e9%87%8f" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>常量指针：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
</span></span></code></pre></div><p>之后你可以使用<code>p = &amp;b</code>来修改p的指向，但是不能使用<code>*p = 30</code>来修改对应的值。</p>
<p>指针常量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
</span></span></code></pre></div><p>可以通过<code>*p = 30</code>来修改值，但是不能改变指向的地址。</p>
<h2 id="c风格数组">C风格数组<a href="#c%e9%a3%8e%e6%a0%bc%e6%95%b0%e7%bb%84" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>当我们将C风格数组作为参数传入函数时，数组名会<strong>退化为指针</strong>。这里就是完全意义上变为指针。</p>
<p>比如，当我们写：<code>void func(int arr[10]){...}</code>的时候，我们就等同于写<code>void func(int* arr)</code>。虽然我们前文中提到数组和指针是完全不同的两种东西，但是这里，数组退化为指针的事情就是真实地发生了。</p>
<p>这样的退化带来的第一个问题就是，我们没办法使用sizeof来获取一个数组的长度。最传统的做法就是添加一个参数来手动传入数组大小。</p>
<p>C风格数组传参时，以下写法是完全等价的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> arr[]);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>]);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> arr);
</span></span></code></pre></div><p>等价的原因就在于无论原本是什么东西，在这里全部都会退化为指针。</p>
<p>但是假如我们需要传入一个多维数组，比如某个<code>int a[3][4]</code>，此时我们就不能写<code>f(a)</code>，原因在我们前面分析指针原则的时候其实涉及到了，程序员有各种各样的方式实现多维数组，所以多维数组没办法直接退化为某个指针。</p>
<p>以二维数组为例，原教旨主义的二维数组就是数组，内存连续。和它的行为最接近的是<strong>数组指针</strong>，所以传参时可以这么写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>a)[<span style="color:#ae81ff">4</span>]);
</span></span></code></pre></div><p>此外，如果确定了列数，你也可以这么写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> a[][<span style="color:#ae81ff">4</span>]);
</span></span></code></pre></div><p>但是<strong>不能</strong>这么写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> a[][]);
</span></span></code></pre></div><h2 id="c风格字符串">C风格字符串<a href="#c%e9%a3%8e%e6%a0%bc%e5%ad%97%e7%ac%a6%e4%b8%b2" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> s1[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
</span></span></code></pre></div><p>等价于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> s1[] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;h&#39;</span>,<span style="color:#e6db74">&#39;e&#39;</span>,<span style="color:#e6db74">&#39;l&#39;</span>,<span style="color:#e6db74">&#39;l&#39;</span>,<span style="color:#e6db74">&#39;o&#39;</span>,<span style="color:#e6db74">&#39;\0&#39;</span>};
</span></span></code></pre></div><p>注意，<code>\0</code>标志一个字符串结束。</p>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> str[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Helloworld!&#34;</span>;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> str <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> str1[] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;H&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;l&#39;</span>, <span style="color:#e6db74">&#39;l&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;\0&#39;</span>};
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> str1 <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> str2[] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;H&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;\0&#39;</span>, <span style="color:#e6db74">&#39;l&#39;</span>, <span style="color:#e6db74">&#39;l&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>};
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> str2 <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Helloworld<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>Hello
</span></span><span style="display:flex;"><span>He
</span></span></code></pre></div><h1 id="基本算法">基本算法<a href="#%e5%9f%ba%e6%9c%ac%e7%ae%97%e6%b3%95" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h1>
<p>在工程实践中，手写排序是被严格禁止的，因为你几乎不可能写的比标准库更好。但是对于考试只能说是不得不品的一环。</p>
<h2 id="冒泡排序">冒泡排序<a href="#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>最佳实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> bubbleSort(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> arr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> arr.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> swapped;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        swapped <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (arr[j] <span style="color:#f92672">&gt;</span> arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>swap(arr[j], arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>                swapped <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果没有发生交换，直接跳出循环
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>swapped) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>基本原理就是进行多次迭代，每次都遍历一遍，如果某个位置前一个数字大于后一个，就将其交换；如果某次迭代的遍历过程中没有进行任何交换，就证明已经完成了从小到大的排序，可以结束计算了。</p>
<p>我们也可以使用原始数组来重写一遍：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bubbleSort</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> len) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> swapped <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> swapped; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    swapped <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (arr[j] <span style="color:#f92672">&gt;</span> arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        arr[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> arr[j];
</span></span><span style="display:flex;"><span>        arr[j] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>        swapped <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span>  bubbleSort(arr, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> arr[i] <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="选择排序">选择排序<a href="#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> selectionSort(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> arr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> arr.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> minIndex <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (arr[j] <span style="color:#f92672">&lt;</span> arr[minIndex]) {
</span></span><span style="display:flex;"><span>                minIndex <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (minIndex <span style="color:#f92672">!=</span> i) {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>swap(arr[i], arr[minIndex]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>原理是每次遍历后把遍历涉及的元素中最小的元素移到前面，之后的遍历不再关注前面的元素。时间复杂度和冒泡排序一致。（但是冒泡排序更方便设定排序规则，所以我更喜欢冒泡排序。）</p>
<p>同样使用原始数组实现一遍：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selectionSort</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> len) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minIndex <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;</span> len; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (arr[j] <span style="color:#f92672">&lt;</span> arr[minIndex]) {
</span></span><span style="display:flex;"><span>        minIndex <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> arr[i];
</span></span><span style="display:flex;"><span>    arr[i] <span style="color:#f92672">=</span> arr[minIndex];
</span></span><span style="display:flex;"><span>    arr[minIndex] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  selectionSort(arr, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> arr[i] <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="快速排序">快速排序<a href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> partition(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> arr, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 优化：三数取中选基准
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (arr[mid] <span style="color:#f92672">&lt;</span> arr[low]) std<span style="color:#f92672">::</span>swap(arr[mid], arr[low]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (arr[high] <span style="color:#f92672">&lt;</span> arr[low]) std<span style="color:#f92672">::</span>swap(arr[high], arr[low]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (arr[high] <span style="color:#f92672">&lt;</span> arr[mid]) std<span style="color:#f92672">::</span>swap(arr[high], arr[mid]);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    T pivot <span style="color:#f92672">=</span> arr[mid];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> low <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> high <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> { i<span style="color:#f92672">++</span>; } <span style="color:#66d9ef">while</span> (arr[i] <span style="color:#f92672">&lt;</span> pivot);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> { j<span style="color:#f92672">--</span>; } <span style="color:#66d9ef">while</span> (arr[j] <span style="color:#f92672">&gt;</span> pivot);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;=</span> j) <span style="color:#66d9ef">return</span> j;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>swap(arr[i], arr[j]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> quickSort(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> arr, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> partition(arr, low, high);
</span></span><span style="display:flex;"><span>        quickSort(arr, low, p);
</span></span><span style="display:flex;"><span>        quickSort(arr, p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 辅助调用接口
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> quickSort(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> arr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>arr.empty()) {
</span></span><span style="display:flex;"><span>        quickSort(arr, <span style="color:#ae81ff">0</span>, arr.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>顾名思义，快速排序算法确实非常快。冒泡排序和选择排序的速度都是$O(n^2)$，而快速排序的时间复杂度则是$O(n\log n)$。我们来尝试理解下它的工作原理。</p>
<p>快速排序的基本思想是：每次从一个分区中选取一个<strong>基准值</strong>，比它大的数字全部移动到右边，比它小的全部移动到左边，以交换过程最后的临界点作为分区界线形成了两个分区，之后再在这两个分区中重复这个过程。这样，每次进行分区就意味着一个数字找到了正确的位置，而分区量呈指数级增长，每次分区计算的用时和总数成正比，故时间复杂度为$O(n\log n)$。</p>
<p>在上面这段代码中，选取基准值的方法是在一个分区的最左、最右和最中间的三个元素中选出中间的那个数字，然后动用两个指针向基准值收缩，实现分区，之后再通过递归完成整体的排序。</p>
<p>原始数组实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>b) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (arr[mid] <span style="color:#f92672">&lt;</span> arr[low])
</span></span><span style="display:flex;"><span>    swap(arr <span style="color:#f92672">+</span> mid, arr <span style="color:#f92672">+</span> low);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (arr[high] <span style="color:#f92672">&lt;</span> arr[low])
</span></span><span style="display:flex;"><span>    swap(arr <span style="color:#f92672">+</span> high, arr <span style="color:#f92672">+</span> low);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (arr[high] <span style="color:#f92672">&lt;</span> arr[mid])
</span></span><span style="display:flex;"><span>    swap(arr <span style="color:#f92672">+</span> high, arr <span style="color:#f92672">+</span> mid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> arr[mid];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> low <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> high <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>      i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (arr[i] <span style="color:#f92672">&lt;</span> arr[mid]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>      j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (arr[j] <span style="color:#f92672">&gt;</span> arr[mid]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;=</span> j)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> j;
</span></span><span style="display:flex;"><span>    swap(arr <span style="color:#f92672">+</span> i, arr <span style="color:#f92672">+</span> j);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quickSort</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> partition(arr, low, high);
</span></span><span style="display:flex;"><span>    quickSort(arr, low, p);
</span></span><span style="display:flex;"><span>    quickSort(arr, low <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>  quickSort(arr, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">9</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> arr[i] <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="线性查找">线性查找<a href="#%e7%ba%bf%e6%80%a7%e6%9f%a5%e6%89%be" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>从头到尾依次查找最符合条件的元素。就像苏格拉底最大的麦穗的寓言故事。</p>
<p>懒得写了。</p>
<h2 id="二分查找">二分查找<a href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>假如你要查找的元素总体是按照从小到大或者从大到小的顺序排列的，那么如果你要找到某个元素的位置就不需要把所有元素都搜一遍。我们只需要每次找到最中间的点，之后如果目标比中值大，则向右寻找，否则想左寻找。这样时间复杂度就大大减少。</p>
<p>以下提供一种基于递归的解法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ctime&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iomanip&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//这一部分是搜索算法。
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">binarySearch</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&gt;</span> high)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (target <span style="color:#f92672">==</span> arr[mid])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> mid;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (target <span style="color:#f92672">&lt;</span> arr[mid])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> binarySearch(arr, low, mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, target);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> binarySearch(arr, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high, target);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">renewArray</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">sizeof</span>(arr) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    arr[i] <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">100</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>sort(arr, arr <span style="color:#f92672">+</span> <span style="color:#ae81ff">9</span>); <span style="color:#75715e">//注意，这里需要进行排序，原因是二分查找只能适用于已经排序的数组。
</span></span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>srand(time(<span style="color:#66d9ef">nullptr</span>));
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>left;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    renewArray();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>setw(<span style="color:#ae81ff">8</span>) <span style="color:#f92672">&lt;&lt;</span> arr[j];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Index: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> binartSearch(arr, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">50</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然而，虽然说着容易，实际实践的时候经常会出现内存越界和死循环的问题。原因是分区的边界情况非常的不好考虑。以下罗列两种公认的最优写法。</p>
<p>第一种被称为“经典精确查找”，做了很多防范问题的措施。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> binarySearch(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> nums, T target) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// [left, right] 闭区间
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;=</span> right) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 防止溢出的写法，等同于 (left + right) / 2
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">==</span> target) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> mid; <span style="color:#75715e">// 找到了
</span></span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (nums[mid] <span style="color:#f92672">&lt;</span> target) {
</span></span><span style="display:flex;"><span>            left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 目标在右半部分
</span></span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            right <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 目标在左半部分
</span></span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 未找到
</span></span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另一种是所谓的“寻找边界写法”，在有目标值的时候返回符合的值中第一个目标的索引值，如果没有则返回第一个大于目标值的位置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> lowerBound(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> nums, T target) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> nums.size(); <span style="color:#75715e">// [left, right) 左闭右开区间
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;</span> right) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> (right <span style="color:#f92672">-</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">&lt;</span> target) {
</span></span><span style="display:flex;"><span>            left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 当 nums[mid] &gt;= target 时，收缩右边界
</span></span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 这样会不断向左逼近第一个等于 target 的位置
</span></span></span><span style="display:flex;"><span>            right <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> left; <span style="color:#75715e">// 此时 left == right
</span></span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="最大公因数">最大公因数<a href="#%e6%9c%80%e5%a4%a7%e5%85%ac%e5%9b%a0%e6%95%b0" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> b <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> a : gcd(b, a <span style="color:#f92672">%</span> b);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>原理是$gcd(a,b) = gcd(b,a\%b)$。</p>

			</div>
			<div class="human posts"><a href="https://brainmade.org/" target="_blank" rel="external noreferrer noopener"><abbr title="I don't hate AIs; but I love humans!"><svg fill="#fff" width="128" height="40" viewBox="0 0 128 40" xmlns="http://www.w3.org/2000/svg">
      <path
         d="M26.306 39.391H11.665a1.28 1.28 0 0 1-1.28-1.28v-3.838H6.399a1.28 1.28 0 0 1-1.28-1.28v-5.336l-4.41-2.198a1.28 1.28 0 0 1-.493-1.855l4.904-7.357v-2.175C5.12 6.298 11.422 0 19.194 0s14.073 6.3 14.075 14.071c-.316 13.912-5.38 11.758-5.59 17.023l-.093 7.018a1.3 1.3 0 0 1-.375.905 1.27 1.27 0 0 1-.905.375zm-13.361-2.559h12.082l.143-7.27c-.132-3.329 5.858-4.122 5.54-15.368-.179-6.356-5.157-11.635-11.515-11.635S7.68 7.713 7.679 14.071v2.559c-.001.253-.075.5-.215.71l-4.315 6.471 3.822 1.91a1.28 1.28 0 0 1 .708 1.145v4.848h3.987a1.28 1.28 0 0 1 1.28 1.28z" />
      <path
         d="M20.186 29.111v-9.644c.059 0 .118.009.177.009 4.885-.006 8.525-4.506 7.511-9.284a1.19 1.19 0 0 0-.911-.911 7.67 7.67 0 0 0-9.049 5.67l-.033-.036a7.66 7.66 0 0 0-7.03-2.085 1.19 1.19 0 0 0-.911.91c-1.014 4.777 2.627 9.277 7.51 9.284.118 0 .246-.014.369-.02v6.106zm1.419-16.072a5.33 5.33 0 0 1 4.062-1.553 5.33 5.33 0 0 1-5.614 5.615 5.3 5.3 0 0 1 1.552-4.061zm-7.904 6.057a5.3 5.3 0 0 1-1.559-4.061 5.323 5.323 0 0 1 5.614 5.615 5.3 5.3 0 0 1-4.055-1.554m38.419-6.79q0 2.346-1.567 3.63-1.567 1.282-4.351 1.283h-7.669V0h7.016q2.807 0 4.242 1.1 1.446 1.087 1.446 3.226 0 1.467-.729 2.481-.718 1.002-2.197 1.357 1.86.244 2.828 1.32.979 1.063.979 2.823zm-4.112-7.491q0-1.161-.663-1.65-.652-.488-1.947-.488h-3.655v4.265h3.677q1.36 0 1.968-.525.62-.537.62-1.601m.892 7.209q0-2.42-3.089-2.42h-4.069v4.938h4.188q1.545 0 2.252-.624.718-.635.718-1.894m16.26 5.194-3.557-6.538h-3.764v6.538H54.63V0h7.658q2.741 0 4.231 1.332 1.49 1.32 1.49 3.8 0 1.808-.913 3.128-.914 1.308-2.47 1.723l4.144 7.235zm-.381-11.94q0-2.481-2.828-2.481h-4.112v5.083h4.199q1.349 0 2.045-.684.696-.685.696-1.919m16.785 11.94-1.36-4.399h-5.841l-1.359 4.399h-3.209L75.386 0h3.785l5.569 17.219zM77.278 2.651l-.066.269q-.109.44-.261 1.002c-.152.563-.725 2.436-1.871 6.184h4.405l-1.512-4.949-.468-1.662zm9.551 14.567V0h3.209v17.219zm15.53 0L95.681 3.959q.196 1.931.196 3.104v10.155h-2.849V0h3.666l6.777 13.37q-.196-1.846-.196-3.361V0h2.85v17.219zM52.63 39.375V28.331q.011-.351.115-3.015-.818 3.257-1.209 4.541l-2.925 9.518h-2.418l-2.925-9.518-1.232-4.541q.139 2.809.139 3.717v10.342h-3.017V22.313h4.548l2.902 9.543.253.92.553 2.289.725-2.736 2.983-10.015h4.526v17.063zm17.64 0-1.44-4.359h-6.184l-1.44 4.359h-3.397l5.919-17.063h4.007l5.896 17.063zm-4.537-14.434-.069.267q-.115.436-.277.993c-.162.557-.767 2.414-1.98 6.128h4.663l-1.601-4.905-.495-1.647zm24.577 5.776q0 2.64-.99 4.614-.979 1.961-2.787 3.003-1.796 1.042-4.122 1.042h-6.564V22.313h5.873q4.099 0 6.345 2.18 2.245 2.167 2.245 6.224m-3.42 0q0-2.748-1.359-4.19-1.359-1.453-3.881-1.453h-2.407v11.54h2.879q2.188 0 3.478-1.586t1.29-4.311m6 8.659V22.313h12.759v2.761h-9.362v4.287h8.66v2.761h-8.66v4.492h9.835v2.761zm15.75 0v-3.693h3.328v3.693zm12.445-12.149q2.082 0 3.662.781 1.58.78 2.422 2.235.833 1.454.833 3.393 0 2.98-1.845 4.676Q124.302 40 121.085 40q-3.208 0-5.005-1.688-1.798-1.688-1.798-4.695c0-3.007.606-3.57 1.817-4.694q1.817-1.696 4.986-1.696m0 2.702q-2.157 0-3.378.97-1.23.97-1.23 2.72 0 1.777 1.22 2.747 1.211.97 3.388.97 2.195 0 3.462-.988 1.258-.997 1.258-2.711 0-1.778-1.23-2.738-1.23-.97-3.491-.97m6.725-13.402-5.062 2.935v3.107h5.062v2.648h-13.331v-6.322q0-2.261 1.031-3.491 1.022-1.23 2.942-1.23 1.4 0 2.422.754 1.012.754 1.334 2.038l5.601-3.42zm-9.244.314q-1.92 0-1.921 2.334v3.393h3.936v-3.465q0-1.113-.53-1.688t-1.486-.575m7.249-10.915a6.5 6.5 0 0 0-.313-2.002q-.321-.969-.814-1.499h-1.845v3.088h-2.063V0h4.901q1.088 1.005 1.703 2.622a9.4 9.4 0 0 1 .615 3.375q0 3.088-1.798 4.748-1.808 1.661-5.119 1.661-3.292 0-5.043-1.67-1.76-1.67-1.76-4.803 0-4.452 3.473-5.664l.776 2.442q-1.012.395-1.533 1.238-.52.844-.52 1.984 0 1.867 1.192 2.837t3.416.97q2.261 0 3.501-.997 1.23-1.005 1.23-2.818z" />
   </svg></abbr></a></div>

<div class="related-posts thin">
	<h2>See Also</h2>
	<ul>
	
	<li><a href="/zh-cn/posts/seu%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A001%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">SEU程序设计复习01：基础语法</a></li>
	
	<li><a href="/zh-cn/posts/%E8%BF%91%E6%97%A5%E7%A5%9E%E5%BF%85%E8%84%91%E6%B4%9E%E5%90%88%E9%9B%86/">近日神必脑洞合集</a></li>
	
	<li><a href="/zh-cn/posts/%E6%A0%B8%E5%8A%A8%E5%8A%9B%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B0%84%E5%99%A8%E6%B5%8B%E8%AF%95/">核动力博客发射器测试</a></li>
	
	</ul>
</div>

		</article>
		<aside id="toc">
			<div class="toc-title">Table of Contents</div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#如何站在c语言老登的视角看待指针">如何站在C语言老登的视角看待指针</a>
      <ul>
        <li><a href="#常量指针指针常量">常量指针&amp;指针常量</a></li>
      </ul>
    </li>
    <li><a href="#c风格数组">C风格数组</a></li>
    <li><a href="#c风格字符串">C风格字符串</a></li>
  </ul>

  <ul>
    <li><a href="#冒泡排序">冒泡排序</a></li>
    <li><a href="#选择排序">选择排序</a></li>
    <li><a href="#快速排序">快速排序</a></li>
    <li><a href="#线性查找">线性查找</a></li>
    <li><a href="#二分查找">二分查找</a></li>
    <li><a href="#最大公因数">最大公因数</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="http://localhost:1313/zh-cn/posts/%E5%B9%B3%E6%9D%BF%E6%B8%B8%E6%88%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%A1%E5%88%9223%E9%98%B6%E6%AE%B5/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left">
      <line x1="19" y1="12" x2="5" y2="12"></line>
      <polyline points="12 19 5 12 12 5"></polyline>
   </svg>&nbsp;Newer</span><br><span>平板游戏环境配置计划：2&amp;3阶段</span>
			</a>
			<a class="prev-post" href="http://localhost:1313/zh-cn/posts/%E8%BF%91%E6%97%A5%E7%A5%9E%E5%BF%85%E8%84%91%E6%B4%9E%E5%90%88%E9%9B%86/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right">
      <line x1="5" y1="12" x2="19" y2="12"></line>
      <polyline points="12 5 19 12 12 19"></polyline>
   </svg></span><br><span>近日神必脑洞合集</span>
			</a>
		</div>
		<div id="comments" class="thin"><script src="https://giscus.app/client.js"
        data-repo="Moonhalf383/Hermit-v2-blog-yorozumoon"
        data-repo-id="R_kgDOQaFILg"
        data-category="Announcements"
        data-category-id="DIC_kwDOQaFILs4CyFGz"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="transparent_dark"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
</div>
	</main>
<footer id="site-footer" class="section-inner thin animated fadeIn faster">
<p>
	&copy; 2026 <a href="http://localhost:1313/">Yorozumoon</a>
	&#183; copyright by Moonhalf
	&#183; Made with <a href="https://gohugo.io/" target="_blank" rel="noopener" title="The world's fastest framework for building websites">Hugo</a> &amp; <a href="https://github.com/1bl4z3r/hermit-V2" target="_blank" rel="noopener" title="A fast, minimalist Hugo theme">Hermit-V2</a>
	</p></footer>
<script async src="http://localhost:1313/js/bundle.min.a2910447d5c22e84c4b04382d8c10c056b2b9d3e15c64d1fa04882359d61afd3.js" integrity="sha256-opEER9XCLoTEsEOC2MEMBWsrnT4Vxk0foEiCNZ1hr9M=" crossorigin="anonymous"></script><script async src="http://localhost:1313/js/link-share.min.24409a4f6e5537d70ffc55ec8f9192208d718678cb8638585342423020b37f39.js" integrity="sha256-JECaT25VN9cP/FXsj5GSII1xhnjLhjhYU0JCMCCzfzk=" crossorigin="anonymous"></script><script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']]
    }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
