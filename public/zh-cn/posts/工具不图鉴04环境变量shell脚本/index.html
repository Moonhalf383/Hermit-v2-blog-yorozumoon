<!DOCTYPE html>
<html lang="zh-cn">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="UTF-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1, minimal-ui">
<meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="robots" content="noindex, nofollow, noarchive"><meta name="author" content="Moonhalf">
<meta name="description" content=""><link rel="manifest" href="/site.webmanifest"><link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<meta name="apple-mobile-web-app-title" content="Yorozumoon" />
<meta name="theme-color" content="#494f5c">
<meta name="msapplication-TileColor" content="#494f5c">

  <meta itemprop="name" content="工具不图鉴04：环境变量&shell脚本">
  <meta itemprop="description" content="D2L自学日志工程量太大了，学一天给我CPU干烧了，索性学点其他的东西调整一下。因为很长一段时间自己从来没有正经的研究过什么是环境变量以及怎么写shell脚本，遇到这种事情都让ai来完成，最近时常感觉自己的环境有点乱糟糟的。归根结底，这种事情还是要自己知道怎么做的好。">
  <meta itemprop="datePublished" content="2026-01-28T00:00:00+00:00">
  <meta itemprop="dateModified" content="2026-01-28T00:00:00+00:00">
  <meta itemprop="wordCount" content="5787">
  <meta itemprop="keywords" content="Blog,教程,Shell,Python"><meta property="og:url" content="http://localhost:1313/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/">
  <meta property="og:site_name" content="Yorozumoon">
  <meta property="og:title" content="工具不图鉴04：环境变量&shell脚本">
  <meta property="og:description" content="D2L自学日志工程量太大了，学一天给我CPU干烧了，索性学点其他的东西调整一下。因为很长一段时间自己从来没有正经的研究过什么是环境变量以及怎么写shell脚本，遇到这种事情都让ai来完成，最近时常感觉自己的环境有点乱糟糟的。归根结底，这种事情还是要自己知道怎么做的好。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-28T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-28T00:00:00+00:00">
    <meta property="article:tag" content="Blog">
    <meta property="article:tag" content="教程">
    <meta property="article:tag" content="Shell">
    <meta property="article:tag" content="Python">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="工具不图鉴04：环境变量&shell脚本">
  <meta name="twitter:description" content="D2L自学日志工程量太大了，学一天给我CPU干烧了，索性学点其他的东西调整一下。因为很长一段时间自己从来没有正经的研究过什么是环境变量以及怎么写shell脚本，遇到这种事情都让ai来完成，最近时常感觉自己的环境有点乱糟糟的。归根结底，这种事情还是要自己知道怎么做的好。">

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "工具不图鉴04：环境变量\u0026shell脚本",
    "name": "工具不图鉴04：环境变量\u0026shell脚本",
    "description": "D2L自学日志工程量太大了，学一天给我CPU干烧了，索性学点其他的东西调整一下。因为很长一段时间自己从来没有正经的研究过什么是环境变量以及怎么写shell脚本，遇到这种事情都让ai来完成，最近时常感觉自己的环境有点乱糟糟的。归根结底，这种事情还是要自己知道怎么做的好。\n",
    "keywords": ["blog", "教程", "shell", "python"],
    "articleBody": "D2L自学日志工程量太大了，学一天给我CPU干烧了，索性学点其他的东西调整一下。因为很长一段时间自己从来没有正经的研究过什么是环境变量以及怎么写shell脚本，遇到这种事情都让ai来完成，最近时常感觉自己的环境有点乱糟糟的。归根结底，这种事情还是要自己知道怎么做的好。\n参考链接： 某篇google上随机刷到的博客\n环境变量wiki\n某个实用工具清单仓库\n什么是环境变量？ 在回答这个问题之前，我们不妨思考一下：\n什么是“变量”？ 即使折腾了有段时间linux，实话说我很少遇到普通变量。但是它们确实存在。我觉得一个比较正确的看待变量的角度是把shell看做一个和python类似的东西，shell可以输一行指令运行一次，python开启交互模式也可以输一行代码运行一次；shell允许你写复杂的shell脚本，python也允许你组织复杂的工程。只不过前者本质是一个实用工具，后者至少打的旗号是一个编程语言。\n我们先用Python举一个简单的例子：\n只要你的电脑安装了python，你就可以随时在命令行中输入python来进入交互模式。我们可以开始时定义一个变量a，然后在接下来的交互中调用它或者修改它。\nshell自身的普通变量也有类似的功能，同样一个简单的例子：\n你完全可以把shell看做是一个基本只运行交互模式的python。只不过shell的变量有以下特殊的语法规则：\n定义变量时等号左右不能有空格，比如你必须写a=3而不是a = 3，虽然后者看起来更加顺眼。 调用变量的时候必须在变量名之前加$。 对变量进行数学计算的时候需要使用两个圆括号括起来。 如果你好奇你的当前环境下有哪些变量，你可以输入set指令来查看所有的变量。这里甚至会包含我们刚刚随手写的一个变量a：\n环境变量 虽然普通变量看起来已经可以做很多事情了，但是它有一个显著的局限：它只能作用于当前的shell进程，甚至没办法作用到任何子进程。假如你运行了一个程序，那么这个程序是读取不到你的普通变量的，或者假如你新开了一个窗口，那么新的shell进程中也是不会有原窗口的普通变量。\n环境变量虽然也不能直接存活在所有窗口，但是相较于普通变量，环境变量的一个重要特点是允许子进程读取。很多的应用会读取一些通用的环境变量来获取目录结构信息以及用户信息，用户也可以通过修改环境变量来配置一些应用的行为。\n在进一步了解环境变量之前，我们最好先来了解一些常用的和变量相关的指令：\necho $VAR echo指令的作用是在你的终端上打印指定的东西。你可以让它打印一个变量的内容，也可以打印字符串。如果你想让你的脚本比较人性化的话你可以考虑多打印一点提示内容。\nexport VAR=var 声明一个变量为环境变量。如果没有export关键字的话默认为普通变量。\nenv 查看所有的环境变量。\nunset VAR 删除一个变量。\n大致就这样。\n一些常见的环境变量： USER：你的名字。如果程序想显示你的名字的时候就会查它。 HOME：家目录。通常就是你的~目录。这是一个路径，存储的形式是字符串。 PWD：当前路径，即运行脚本时你所处的实际路径。写脚本的时候可能会很有用。 PATH：这是一个“工具箱搜索清单”，存储的是若干个路径，对应目录下里面装的是可执行文件。当你在命令行里输入一个指令时，系统就会去PATH存储的路径中挨个找你要的名字匹配的可执行文件，找到了就执行，找不到就报错，除非设置了别名。 PATH变量中，不同的目录之间通过冒号隔开。一般的添加PATH路径的方式如下：\nexport PATH=\"$HOME/.local/bin:$PATH\" PATH本质是一个字符串，所以用双引号包裹。在想要添加的路径之后补上:$PATH来保留原有的PATH路径，如果不加这个的话原有的路径就都没了。\n如何让一个环境变量可以在所有shell进程中存在？ 修改你的shell的运行时配置文件，也就是.xxrc文件。比如如果你用的shell是bash，那么通常在你的家目录下会有一个.bashrc文件。你只需要把你原本在终端中直接输入的export VAR=var原封不动地搬到配置文件中就可以了。如果你用的是zsh，那就应该搬到~/.zshrc中。\n在我前两天配置proot游戏运行环境过程中配置了大量的环境变量，其中一些基本不用修改的环境变量便存放在了~/.zshrc中，内容大致如下：\n# ========================================== # 1. 基础路径与环境 # ========================================== export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin export DISPLAY=:1 export XDG_RUNTIME_DIR=/tmp # ========================================== # 2. Wine WOW64 路径配置 # ========================================== export WINE_ROOT=$HOME/wine-wow64/wine-11.0-staging-amd64-wow64 export WINEPREFIX=$HOME/.wine export PATH=$WINE_ROOT/bin:$PATH # 确保 Wine 能找到它自己的库文件 export LD_LIBRARY_PATH=$WINE_ROOT/lib:$WINE_ROOT/lib/wine/x86_64-unix:$LD_LIBRARY_PATH # ========================================== # 3. Audio 修复 (基于之前的测试教训) # ========================================== # 解决音频卡顿和死锁的关键：强制通过 TCP 连接宿主 PulseAudio export PULSE_SERVER=127.0.0.1 # 增加延迟缓冲，解决爆音和因音频同步导致的画面卡顿 (Steam 环境建议 60-100) export PULSE_LATENCY_MSEC=60 # ========================================== # 4. Box64 性能与转译优化 (针对 8 Gen 3) # ========================================== # 日志级别：0=仅报错, 1=基本信息。平时建议设为 0 或 1，设太高会拖慢 I/O export BOX64_LOG=1 # 开启大块编译：显著提升 CPU 密集型任务性能 (如游戏逻辑) export BOX64_DYNAREC_BIGBLOCK=1 # 强内存模型：解决 Unity 引擎和多线程游戏死锁/崩溃问题 (骁龙必须开) export BOX64_DYNAREC_STRONGMEM=1 # 安全标志位：防止非法指令崩溃 export BOX64_DYNAREC_SAFEFLAGS=1 # Box64 辅助路径 export BOX64_PATH=$WINE_ROOT/bin/ export BOX64_LD_LIBRARY_PATH=$WINE_ROOT/lib/wine/x86_64-unix/:$WINE_ROOT/lib/ # ========================================== # 5. 图形驱动 (Turnip + Zink) # ========================================== # [重要] 请确认此文件路径真实存在，否则无法加载驱动 export VK_ICD_FILENAMES=/root/test/freedreno_icd.aarch64.json # 强制 Wine/Linux 程序使用 Zink (OpenGL over Vulkan) export MESA_LOADER_DRIVER_OVERRIDE=zink export GALLIUM_DRIVER=zink # Turnip 驱动内存分配修复 (防止显存分配崩溃) export TU_DEBUG=sysmem # Zink 优化：延迟描述符更新，可提升部分 DX9/DX11 游戏帧数 export ZINK_DESCRIPTORS=lazy export WINEDEBUG=\"-file,-mountmgr,-event\" # ========================================== # 6. 调试辅助 (可选，平时可注释掉) # ========================================== # 显示 DXVK 帧数和显卡信息 (如果你装了 DXVK) # export DXVK_HUD=fps,devinfo,version # 显示 Mesa/Zink 帧数 (如果你没用 DXVK) # export GALLIUM_HUD=fps （看到这么激情洋溢的注释就知道是ai写的了…）\n每次进入proot环境，系统会花一点时间打开zsh，这一过程中系统就会首先运行~/.zshrc中的shell指令，所以将环境变量写在这里，每次启动shell就会自动添加这些环境变量。\nshell脚本 一个helloworld地位的脚本：\n#!/usr/bin/env bash echo \"Hello world!\" shell script虽然定位上被认为是“脚本语言”而非通用型语言，但是脚本语言也是编程语言的一种。python很多时候也不过就是一个高级一点的通用脚本。所以此处你完全可以把.sh和.py看做是一类东西。\n现在我们来拆解一下这个helloworld代码的组成。\n#!/usr/bin/env bash 这个东西的专业术语是Shebang，它的作用是告诉系统内核这个文件不是一个可以直接执行的二进制文件，而是一个需要解释器才能运行的脚本文件，#!后放的就是解释器的文件路径。\n然而，你可能会注意到#!/usr/bin/env bash似乎并不是直接代表了一个解释器路径，这里其实是一种常见的变体。env是一个存在于/usr/bin的二进制文件，它的位置一般来说是稳定不变的，但是在不同人的电脑上，解释器的位置是很有可能变化的。env后加一个程序名表示的就是在PATH环境变量中寻找对应的解释器。这样不管解释器在哪，脚本都可以正常运行。\n常见的shell script解释器有sh或者dash，属于标准的POSIX shell，功能较少但是速度较快，bash会比较中规中矩，而且一般机器上都会有。zsh会有一些高级特性。\n此外，既然Shebang只是规定必须写一个解释器路径，其实我们不止可以写shell script，还可以写python。你只需要把Shebang中的bash换成python，后面的脚本用python语法写，完全可以正常运行。\nchmod +x … chmod，即Change Mode。脚本写完之后无法直接运行，需要使用chmod为它添加执行权限。三种基本权限即rwx，对应读取权限、写入权限，以及执行权限。对于个人电脑来说我们很少会接触到用户组的概念，所以一般最常见的用法就是chmod +x 来为脚本添加执行权限，或者chmod -x 来取消脚本的执行权限。\n一些常见的脚本写法 #!/usr/bin/env bash echo \"Enter a numble:\" read NUMBLE if [ $NUMBLE -gt 10 ]; then echo \"The numble is greater than 10.\" exit 1 elif [ $NUMBLE -eq 10 ]; then echo \"The numble is equal to 10.\" exit 1 else echo \"The numble is less than 10.\" fi 这个简单的例子里涉及了shell script的条件判断写法。在shell script中-gt代表大于，-eq代表等于，-lt表示小于。此外需要注意变量取值必须在变量名前加$（比C语言还繁琐是我没想到的）。shell script是一个弱类型语言，无需显示声明类型，所有的变量会默认存储为字符串。\n注意中括号和中间的关键字和标识符之间需要留有空格，中括号之后要加分号。shell script对于空格、分号和中括号非常敏感。分支结构最后需要加上fi表示结束。\n运行效果：\nfor循环写法：\n#!/usr/bin/env bash echo \"Generating three test files...\" for i in {1..3}; do touch \"test_file_$i.txt\" echo \"File NO.$i created successfully.\" done echo \"Mission completed.\" 创建三个测试用文件（竟然是左闭右闭，简直是异端）。运行结果如下：\n在shell script中有一些特殊的变量由系统自动维护，用来获取脚本参数、运行状态和系统id。\n$0返回运行的脚本文件名（实际是相对于当前位置的相对路径） $1、$2、...表示传给脚本的第1～9个参数。 ${10}，10及以上需要加花括号。 $#传入的参数个数 $@传入的所有参数，可以使用for循环遍历（即把参数打包成一个类似python元组的东西） $*把传入的参数看做一个整体的字符串。 $?上一个命令退出情况，0为成功，非0为失败。 $$当前脚本的进程数。 一个求和脚本示例：\n#!/usr/bin/env bash DATE=$(date \"+%Y-%m-%d\") echo \"PID: $$\" echo \"Date: $DATE\" echo \"Script name: $0\" echo \"\" echo \"You've entered $# params.\" ANS=0 for PARAM in \"$@\"; do ANS=$(($ANS + PARAM)) done echo \"The sum is $ANS.\" 结果：\nshell的for循环语法和python看起来似乎很相似。比如，你可以这么写：\nfor name in Alice Bob Charlie; do echo \"Hello $name\" done 结果输出：\nHello Alice Hello Bob Hello Charlie shell script中一个更强大的功能是通配符遍历。比如，如果你想罗列一个目录下的所有pdf文件，你可以这么写：\n#!/usr/bin/env bash count=1 for file in *.pdf; do echo \"pdf $count: $file\" count=$(($count + 1)) done 效果：\n如果你想使用C风格的数值循环，此处记录一下写法，不再实验。\nfor ((i=1; i\u003c=5; i++)); do echo \"次数: $i\" done while循环的一般写法也就是if和for的杂交，也只是记录一下，不再实验。\ncount=1 while [ $count -le 5 ]; do echo \"Count: $count\" ((count++)) # Bash 中的自增写法 done 插叙：重定向与管道 在linux命令中，|、\u003e、\u003c可以影响数据的流向，为我们编写脚本和日常使用指令提供了极大的方便。理解这些工具的秘诀在于想象数据像水一样流动。\n\u003e和\u003e\u003e表示输出重定向。它们可以把原本应该打印在屏幕上的内容存到指定的文件中。其中\u003e表示覆写，会清空原有内容；\u003e\u003e表示追加写，会在文件末尾接着写。\n你应该这样理解：每一个指令都像一个有着通用的输入、输出管道的机器。默认情况下，输出的管道会直接连到你的终端上。现在，我们不希望它把数据直接流到屏幕上，而是流到文件里，所以我们接一个管道把指令输出的东西转移到文件中。\necho \"Hello\" \u003e hello.txt echo \"Helloworld\" \u003e\u003e hello.txt 结果：\n内容：\nHello Helloworld echo指令就像是一个只会接受东西输出东西的发射器，但是它也使用了通用的管道。\n一个常见的应用是conda导出环境配置。此处就用到了输出重定向。\nconda env export \u003e environment.yml # 导出环境 此外，正常的输出\u003e实际是1\u003e的缩写。错误输出2\u003e和正常输出并不走同一个管道。这意味着有时即使你进行了\u003e的重定向，当出现错误时，报错信息还是会流到屏幕上。你需要对报错做额外的处理。\n与之相对的，\u003c表示输入重定向。比如某些指令默认从屏幕读取输入，你就可以用\u003c来将默认的输入方式改为从指定的文件中输入。每次会自动读取一行。\n举个例子，我们随便写一个若干行的随机人名文件。\n然后编写这样的测试脚本：\n#!/usr/bin/env bash FILE=\"$PWD/names.txt\" while read name; do echo $name done \u003c$FILE FILE定义了指定的文件，此处我们默认在names.txt目录下执行该脚本。假如你在一个没有names.txt的目录下执行该脚本，脚本就会报错。\n运行效果：\n符合预期。\n然而，仅有输入输出重定向是不够的。它们只能代表数据加工开始和结束时数据的去向。但是假如数据加工的过程中也有多个步骤，仅仅使用输入输出重定向虽然也可以完成任务，但是免不了要用额外的存储空间缓存数据，并徒增写入和读取的用时。所以，我们为什么不能直接把一个指令的输出喂给另一个指令作为输入呢？\n于是便有了管道符号|。它的作用就是把左边指令的输出喂给右边的指令作为输入。一些经典的用法如下：\n# 1. 列出当前目录所有文件 # 2. 把结果传给 grep，搜索包含 \"txt\" 的行 ls | grep \"txt\" # 1. 读取一个很长的文件内容 # 2. 把内容传给 head，只看前 10 行 cat large_file.log | head -n 10 # 1. 查找所有正在运行的进程 # 2. 搜索关于 \"python\" 的进程 ps aux | grep \"python\" 函数与递归 虽然shell脚本看起来像是一堆指令堆在一起，但是实际上完全支持函数和递归调用。\n一个简单的函数示例：\n#!/usr/bin/env bash add() { echo $(($1 + $2)) } echo $(add $1 $2) 输出结果：\nshell函数相较于其他语言的函数有很大的行为差异。首先，shell script中的函数传参只能使用$i的形式读取第i个参数。此外，在shell中return关键字的用法是返回状态，只能返回0~255之间的整数，通常用0表示成功。而数据输出则使用echo，并在函数调用的时候使用$(...)符号捕获输出。这种设计的原因在于shell script本身是非常简陋的，想要返回数值唯一的方法就是把东西打印出来。\n$(...)符号在shell script中的行为和输出重定向很相似。它的功能就是把一个原本会输出到屏幕的输出重定向给变量。$VAR的写法则表示从变量的对应内存中提取数据。两者的功能是不同的。\nshell script中定义的变量默认是全局变量，这和一般的程序语言的动态作用域有很大区别。如果我们希望一个变量只作用于函数体内部，我们必须要变量前添加local关键字。\nshell script完全支持递归，以下是基于shell script的阶乘写法：\n#!/usr/bin/env bash fact() { if [ $1 -le 1 ]; then echo 1 else local prev=$(fact $(($1 - 1))) echo $(($prev * $1)) fi } echo $(fact $1) 输出结果：\n一个基于shell script递归的文件树打印脚本：\n#!/usr/bin/env bash echo_indent() { local indent=\"$1\" local ans=\"$2\" for ((i = 1; i \u003c= indent; i++)); do ans=\" $ans\" done echo \"$ans\" } list_file_recursive() { local dir=\"$1\" local indent=\"$2\" for item in $dir/*; do if [ -d \"$item\" ]; then echo \"$(echo_indent $indent \"Directory: $item\")\" list_file_recursive \"$item\" $(($indent + 1)) else echo \"$(echo_indent $indent \"File: $item\")\" fi done } list_file_recursive $PWD 0 某次输出：\n（下方lt为eza输出的文件树，可以当做标准答案。）\n总结 虽然shell script的功能很多，但是写起来和正经的程序语言比还是有点折磨了。这边推荐把shell script当做python程序的包装器。\n以下是我的博客发射器的包装器脚本：\n#!/usr/bin/env bash set -e PROJECT_ROOT=\"$HOME/python_projects/ControlCenter\" VENV_ACTIVATE=\"$PROJECT_ROOT/venv/bin/activate\" ENTRY_POINT=\"$PROJECT_ROOT/Entry.py\" if [ ! -d \"$PROJECT_ROOT\" ]; then echo \"Error: Project directory not found at $PROJECT_ROOT\" exit 1 fi if [ -f \"$VENV_ACTIVATE\" ]; then source \"$VENV_ACTIVATE\" else echo \"Error: Virtual environment not found. Did you run 'python -m venv venv'?\" exit 1 fi python \"$ENTRY_POINT\" \"$@\" deactivate 功能是自动启动虚拟环境并运行python程序，同时自动传参执行指令。随后结束时自动关闭虚拟环境。至于具体的功能实现则交给代码更便于维护的python程序。\n",
    "wordCount" : "5787",
    "inLanguage": "zh-cn",
    "datePublished": "2026-01-28T00:00:00Z",
    "dateModified": "2026-01-28T00:00:00Z",
    "author":{
        "@type": "Person",
        "name": "Moonhalf",
        "url": "http://localhost:1313/zh-cn/%E6%9C%88%E3%81%AE%E3%81%BE%E3%81%AB%E3%81%BE%E3%81%AB/"
        },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http://localhost:1313/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Yorozumoon",
      "description": "",
      "logo": {
        "@type": "ImageObject",
        "url": "http://localhost:1313/favicon.ico"
      }
    }
}
</script><title>工具不图鉴04：环境变量&amp;shell脚本</title><link rel="stylesheet dns-prefetch preconnect preload prefetch" as="style" media="screen" href="http://localhost:1313/css/style.min.7c4faf57019635cba7aa1b7c6581baeb1ec040f9c7d861be87c059d42585582c.css" integrity="sha256-fE+vVwGWNcunqht8ZYG66x7AQPnH2GG+h8BZ1CWFWCw=" crossorigin="anonymous">
	</head>

<body id="page">
<header id="site-header" class="animated slideInUp">
	<div class="hdr-wrapper section-inner">
		<div class="hdr-left">
			<div class="site-branding">
				<a href="http://localhost:1313/">Yorozumoon</a>
			</div>
			<nav class="site-nav hide-in-mobile"><a href="http://localhost:1313/zh-cn/posts/">文章</a><a href="http://localhost:1313/zh-cn/tags/">标签</a><a href="http://localhost:1313/zh-cn/about/">关于</a><a href="http://localhost:1313/zh-cn/links/">友链</a></nav>
		</div>
		<div class="hdr-right hdr-icons">
			<button id="toc-btn" class="hdr-btn desktop-only-ib" title="Table Of Contents"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list">
      <line x1="8" y1="6" x2="21" y2="6"></line>
      <line x1="8" y1="12" x2="21" y2="12"></line>
      <line x1="8" y1="18" x2="21" y2="18"></line>
      <line x1="3" y1="6" x2="3" y2="6"></line>
      <line x1="3" y1="12" x2="3" y2="12"></line>
      <line x1="3" y1="18" x2="3" y2="18"></line>
   </svg></button><span class="hdr-links hide-in-mobile"><a href="https://github.com/Moonhalf383" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none"
   stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
   <path
      d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
   </path>
</svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
   </svg></button>
		</div>
	</div>
</header>
<div id="mobile-menu" class="animated fast">
	<ul>
		<li><a href="http://localhost:1313/zh-cn/posts/">文章</a></li>
		<li><a href="http://localhost:1313/zh-cn/tags/">标签</a></li>
		<li><a href="http://localhost:1313/zh-cn/about/">关于</a></li>
		<li><a href="http://localhost:1313/zh-cn/links/">友链</a></li>
	</ul>
</div>

	<main class="site-main section-inner animated fadeIn faster"><article class="thin">
			<header class="post-header">
				<div class="post-date"><span>Jan 28, 2026</span></div>
				<h1>工具不图鉴04：环境变量&amp;shell脚本</h1>
			</header>
			<div class="post-description"><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
   stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-feather">
   <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
   <line x1="16" y1="8" x2="2" y2="22"></line>
   <line x1="17.5" y1="15" x2="9" y2="15"></line>
</svg><a href="http://localhost:1313/zh-cn/%E6%9C%88%E3%81%AE%E3%81%BE%E3%81%AB%E3%81%BE%E3%81%AB/" target="_blank">Moonhalf</a></p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon">
      <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
      <line x1="7" y1="7" x2="7" y2="7"></line>
   </svg><span class="tag"><a href="http://localhost:1313/zh-cn/tags/blog">blog</a></span><span class="tag"><a href="http://localhost:1313/zh-cn/tags/%E6%95%99%E7%A8%8B">教程</a></span><span class="tag"><a href="http://localhost:1313/zh-cn/tags/shell">shell</a></span><span class="tag"><a href="http://localhost:1313/zh-cn/tags/python">python</a></span></p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
      <polyline points="14 2 14 8 20 8"></polyline>
      <line x1="16" y1="13" x2="8" y2="13"></line>
      <line x1="16" y1="17" x2="8" y2="17"></line>
      <polyline points="10 9 9 9 8 9"></polyline>
   </svg>5787&nbspWords 阅读时长26 Minutes, 18 Seconds</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
      <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
      <line x1="16" y1="2" x2="16" y2="6"></line>
      <line x1="8" y1="2" x2="8" y2="6"></line>
      <line x1="3" y1="10" x2="21" y2="10"></line>
   </svg>2026-01-28 00:00 &#43;0000
</p></div>
			<hr class="post-end">
			<div class="content">
				 <p>D2L自学日志工程量太大了，学一天给我CPU干烧了，索性学点其他的东西调整一下。因为很长一段时间自己从来没有正经的研究过什么是环境变量以及怎么写shell脚本，遇到这种事情都让ai来完成，最近时常感觉自己的环境有点乱糟糟的。归根结底，这种事情还是要自己知道怎么做的好。</p>
<h1 id="参考链接">参考链接：<a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h1>
<p><a href="https://chihokyo.com/post/6/">某篇google上随机刷到的博客</a></p>
<p><a href="https://zh.wikipedia.org/zh-cn/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量wiki</a></p>
<p><a href="https://github.com/alebcay/awesome-shell">某个实用工具清单仓库</a></p>
<h1 id="什么是环境变量">什么是环境变量？<a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h1>
<p>在回答这个问题之前，我们不妨思考一下：</p>
<h2 id="什么是变量">什么是“变量”？<a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%98%e9%87%8f" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>即使折腾了有段时间linux，实话说我很少遇到普通变量。但是它们确实存在。我觉得一个比较正确的看待变量的角度是把shell看做一个和python类似的东西，shell可以输一行指令运行一次，python开启交互模式也可以输一行代码运行一次；shell允许你写复杂的shell脚本，python也允许你组织复杂的工程。只不过前者本质是一个实用工具，后者至少打的旗号是一个编程语言。</p>
<p>我们先用Python举一个简单的例子：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260128-1.png" alt=""></p>
<p>只要你的电脑安装了python，你就可以随时在命令行中输入<code>python</code>来进入交互模式。我们可以开始时定义一个变量<code>a</code>，然后在接下来的交互中调用它或者修改它。</p>
<p>shell自身的普通变量也有类似的功能，同样一个简单的例子：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260128-2.png" alt=""></p>
<p>你完全可以把shell看做是一个基本只运行交互模式的python。只不过shell的变量有以下特殊的语法规则：</p>
<ul>
<li>定义变量时等号左右不能有空格，比如你必须写<code>a=3</code>而不是<code>a = 3</code>，虽然后者看起来更加顺眼。</li>
<li>调用变量的时候必须在变量名之前加<code>$</code>。</li>
<li>对变量进行数学计算的时候需要使用两个圆括号括起来。</li>
</ul>
<p>如果你好奇你的当前环境下有哪些变量，你可以输入<code>set</code>指令来查看所有的变量。这里甚至会包含我们刚刚随手写的一个变量a：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260128-3.png" alt=""></p>
<h2 id="环境变量">环境变量<a href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>虽然普通变量看起来已经可以做很多事情了，但是它有一个显著的局限：它<strong>只能作用于当前的shell进程</strong>，甚至没办法作用到任何子进程。假如你运行了一个程序，那么这个程序是读取不到你的普通变量的，或者假如你新开了一个窗口，那么新的shell进程中也是不会有原窗口的普通变量。</p>
<p>环境变量虽然也不能直接存活在所有窗口，但是相较于普通变量，环境变量的一个重要特点是允许子进程读取。很多的应用会读取一些通用的环境变量来获取目录结构信息以及用户信息，用户也可以通过修改环境变量来配置一些应用的行为。</p>
<p>在进一步了解环境变量之前，我们最好先来了解一些常用的和变量相关的指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo $VAR
</span></span></code></pre></div><p><code>echo</code>指令的作用是在你的终端上打印指定的东西。你可以让它打印一个变量的内容，也可以打印字符串。如果你想让你的脚本比较人性化的话你可以考虑多打印一点提示内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>export VAR<span style="color:#f92672">=</span>var
</span></span></code></pre></div><p>声明一个变量为环境变量。如果没有export关键字的话默认为普通变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>env
</span></span></code></pre></div><p>查看所有的环境变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>unset VAR
</span></span></code></pre></div><p>删除一个变量。</p>
<p>大致就这样。</p>
<h3 id="一些常见的环境变量">一些常见的环境变量：<a href="#%e4%b8%80%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260128-4.png" alt=""></p>
<ul>
<li>USER：你的名字。如果程序想显示你的名字的时候就会查它。</li>
<li>HOME：家目录。通常就是你的<code>~</code>目录。这是一个路径，存储的形式是字符串。</li>
<li>PWD：当前路径，即运行脚本时你所处的实际路径。写脚本的时候可能会很有用。</li>
</ul>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260128-5.png" alt=""></p>
<ul>
<li>PATH：这是一个“工具箱搜索清单”，存储的是若干个路径，对应目录下里面装的是可执行文件。当你在命令行里输入一个指令时，系统就会去PATH存储的路径中挨个找你要的名字匹配的可执行文件，找到了就执行，找不到就报错，除非设置了别名。</li>
</ul>
<p>PATH变量中，不同的目录之间通过冒号隔开。一般的添加PATH路径的方式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/.local/bin:</span>$PATH<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><p>PATH本质是一个字符串，所以用双引号包裹。在想要添加的路径之后补上<code>:$PATH</code>来保留原有的PATH路径，如果不加这个的话原有的路径就都没了。</p>
<h3 id="如何让一个环境变量可以在所有shell进程中存在">如何让一个环境变量可以在所有shell进程中存在？<a href="#%e5%a6%82%e4%bd%95%e8%ae%a9%e4%b8%80%e4%b8%aa%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e5%8f%af%e4%bb%a5%e5%9c%a8%e6%89%80%e6%9c%89shell%e8%bf%9b%e7%a8%8b%e4%b8%ad%e5%ad%98%e5%9c%a8" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>修改你的shell的<strong>运行时配置文件</strong>，也就是<code>.xxrc</code>文件。比如如果你用的shell是bash，那么通常在你的家目录下会有一个<code>.bashrc</code>文件。你只需要把你原本在终端中直接输入的<code>export VAR=var</code>原封不动地搬到配置文件中就可以了。如果你用的是zsh，那就应该搬到<code>~/.zshrc</code>中。</p>
<p>在我前两天配置proot游戏运行环境过程中配置了大量的环境变量，其中一些基本不用修改的环境变量便存放在了<code>~/.zshrc</code>中，内容大致如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. 基础路径与环境</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</span></span><span style="display:flex;"><span>export DISPLAY<span style="color:#f92672">=</span>:1
</span></span><span style="display:flex;"><span>export XDG_RUNTIME_DIR<span style="color:#f92672">=</span>/tmp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Wine WOW64 路径配置</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span>export WINE_ROOT<span style="color:#f92672">=</span>$HOME/wine-wow64/wine-11.0-staging-amd64-wow64
</span></span><span style="display:flex;"><span>export WINEPREFIX<span style="color:#f92672">=</span>$HOME/.wine
</span></span><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span>$WINE_ROOT/bin:$PATH
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 确保 Wine 能找到它自己的库文件</span>
</span></span><span style="display:flex;"><span>export LD_LIBRARY_PATH<span style="color:#f92672">=</span>$WINE_ROOT/lib:$WINE_ROOT/lib/wine/x86_64-unix:$LD_LIBRARY_PATH
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Audio 修复 (基于之前的测试教训)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 解决音频卡顿和死锁的关键：强制通过 TCP 连接宿主 PulseAudio</span>
</span></span><span style="display:flex;"><span>export PULSE_SERVER<span style="color:#f92672">=</span>127.0.0.1
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 增加延迟缓冲，解决爆音和因音频同步导致的画面卡顿 (Steam 环境建议 60-100)</span>
</span></span><span style="display:flex;"><span>export PULSE_LATENCY_MSEC<span style="color:#f92672">=</span><span style="color:#ae81ff">60</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Box64 性能与转译优化 (针对 8 Gen 3)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 日志级别：0=仅报错, 1=基本信息。平时建议设为 0 或 1，设太高会拖慢 I/O</span>
</span></span><span style="display:flex;"><span>export BOX64_LOG<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 开启大块编译：显著提升 CPU 密集型任务性能 (如游戏逻辑)</span>
</span></span><span style="display:flex;"><span>export BOX64_DYNAREC_BIGBLOCK<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 强内存模型：解决 Unity 引擎和多线程游戏死锁/崩溃问题 (骁龙必须开)</span>
</span></span><span style="display:flex;"><span>export BOX64_DYNAREC_STRONGMEM<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 安全标志位：防止非法指令崩溃</span>
</span></span><span style="display:flex;"><span>export BOX64_DYNAREC_SAFEFLAGS<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Box64 辅助路径</span>
</span></span><span style="display:flex;"><span>export BOX64_PATH<span style="color:#f92672">=</span>$WINE_ROOT/bin/
</span></span><span style="display:flex;"><span>export BOX64_LD_LIBRARY_PATH<span style="color:#f92672">=</span>$WINE_ROOT/lib/wine/x86_64-unix/:$WINE_ROOT/lib/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. 图形驱动 (Turnip + Zink)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># [重要] 请确认此文件路径真实存在，否则无法加载驱动</span>
</span></span><span style="display:flex;"><span>export VK_ICD_FILENAMES<span style="color:#f92672">=</span>/root/test/freedreno_icd.aarch64.json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 强制 Wine/Linux 程序使用 Zink (OpenGL over Vulkan)</span>
</span></span><span style="display:flex;"><span>export MESA_LOADER_DRIVER_OVERRIDE<span style="color:#f92672">=</span>zink
</span></span><span style="display:flex;"><span>export GALLIUM_DRIVER<span style="color:#f92672">=</span>zink
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Turnip 驱动内存分配修复 (防止显存分配崩溃)</span>
</span></span><span style="display:flex;"><span>export TU_DEBUG<span style="color:#f92672">=</span>sysmem
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Zink 优化：延迟描述符更新，可提升部分 DX9/DX11 游戏帧数</span>
</span></span><span style="display:flex;"><span>export ZINK_DESCRIPTORS<span style="color:#f92672">=</span>lazy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export WINEDEBUG<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-file,-mountmgr,-event&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 6. 调试辅助 (可选，平时可注释掉)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ==========================================</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 显示 DXVK 帧数和显卡信息 (如果你装了 DXVK)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># export DXVK_HUD=fps,devinfo,version</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 显示 Mesa/Zink 帧数 (如果你没用 DXVK)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># export GALLIUM_HUD=fps</span>
</span></span></code></pre></div><p>（看到这么激情洋溢的注释就知道是ai写的了&hellip;）</p>
<p>每次进入proot环境，系统会花一点时间打开zsh，这一过程中系统就会首先运行<code>~/.zshrc</code>中的shell指令，所以将环境变量写在这里，每次启动shell就会自动添加这些环境变量。</p>
<h1 id="shell脚本">shell脚本<a href="#shell%e8%84%9a%e6%9c%ac" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h1>
<p>一个helloworld地位的脚本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Hello world!&#34;</span>
</span></span></code></pre></div><p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260128-6.png" alt=""></p>
<p>shell script虽然定位上被认为是“脚本语言”而非通用型语言，但是脚本语言也是编程语言的一种。python很多时候也不过就是一个高级一点的通用脚本。所以此处你完全可以把<code>.sh</code>和<code>.py</code>看做是一类东西。</p>
<p>现在我们来拆解一下这个helloworld代码的组成。</p>
<h2 id="usrbinenv-bash">#!/usr/bin/env bash<a href="#usrbinenv-bash" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>这个东西的专业术语是<strong>Shebang</strong>，它的作用是告诉系统内核这个文件不是一个可以直接执行的二进制文件，而是一个需要解释器才能运行的脚本文件，<code>#!</code>后放的就是解释器的文件路径。</p>
<p>然而，你可能会注意到<code>#!/usr/bin/env bash</code>似乎并不是直接代表了一个解释器路径，这里其实是一种常见的变体。<code>env</code>是一个存在于<code>/usr/bin</code>的二进制文件，它的位置一般来说是稳定不变的，但是在不同人的电脑上，解释器的位置是很有可能变化的。<code>env</code>后加一个程序名表示的就是在PATH环境变量中寻找对应的解释器。这样不管解释器在哪，脚本都可以正常运行。</p>
<p>常见的shell script解释器有sh或者dash，属于标准的POSIX shell，功能较少但是速度较快，bash会比较中规中矩，而且一般机器上都会有。zsh会有一些高级特性。</p>
<p>此外，既然Shebang只是规定必须写一个解释器路径，其实我们不止可以写shell script，还可以写python。你只需要把Shebang中的bash换成python，后面的脚本用python语法写，完全可以正常运行。</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260129-1.png" alt=""></p>
<h2 id="chmod-x-">chmod +x &hellip;<a href="#chmod-x-" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>chmod，即<strong>Ch</strong>ange <strong>Mod</strong>e。脚本写完之后无法直接运行，需要使用chmod为它添加执行权限。三种基本权限即rwx，对应读取权限、写入权限，以及执行权限。对于个人电脑来说我们很少会接触到用户组的概念，所以一般最常见的用法就是<code>chmod +x &lt;file_name&gt;</code>来为脚本添加执行权限，或者<code>chmod -x &lt;file_name&gt;</code>来取消脚本的执行权限。</p>
<h1 id="一些常见的脚本写法">一些常见的脚本写法<a href="#%e4%b8%80%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e8%84%9a%e6%9c%ac%e5%86%99%e6%b3%95" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Enter a numble:&#34;</span>
</span></span><span style="display:flex;"><span>read NUMBLE
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $NUMBLE -gt <span style="color:#ae81ff">10</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;The numble is greater than 10.&#34;</span>
</span></span><span style="display:flex;"><span>  exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">elif</span> <span style="color:#f92672">[</span> $NUMBLE -eq <span style="color:#ae81ff">10</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;The numble is equal to 10.&#34;</span>
</span></span><span style="display:flex;"><span>  exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;The numble is less than 10.&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span> 
</span></span></code></pre></div><p>这个简单的例子里涉及了shell script的条件判断写法。在shell script中<code>-gt</code>代表大于，<code>-eq</code>代表等于，<code>-lt</code>表示小于。此外需要注意变量取值必须在变量名前加<code>$</code>（比C语言还繁琐是我没想到的）。shell script是一个弱类型语言，无需显示声明类型，所有的变量会默认存储为字符串。</p>
<p>注意中括号和中间的关键字和标识符之间需要留有空格，中括号之后要加分号。shell script对于空格、分号和中括号非常敏感。分支结构最后需要加上<code>fi</code>表示结束。</p>
<p>运行效果：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260129-2.png" alt=""></p>
<p>for循环写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Generating three test files...&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i in <span style="color:#f92672">{</span>1..3<span style="color:#f92672">}</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  touch <span style="color:#e6db74">&#34;test_file_</span>$i<span style="color:#e6db74">.txt&#34;</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;File NO.</span>$i<span style="color:#e6db74"> created successfully.&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Mission completed.&#34;</span>
</span></span></code></pre></div><p>创建三个测试用文件（竟然是左闭右闭，简直是异端）。运行结果如下：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260129-3.png" alt=""></p>
<p>在shell script中有一些特殊的变量由系统自动维护，用来获取脚本参数、运行状态和系统id。</p>
<ul>
<li><code>$0</code>返回运行的脚本文件名（实际是相对于当前位置的相对路径）</li>
<li><code>$1、$2、...</code>表示传给脚本的第1～9个参数。</li>
<li><code>${10}</code>，10及以上需要加花括号。</li>
<li><code>$#</code>传入的参数个数</li>
<li><code>$@</code>传入的所有参数，可以使用for循环遍历（即把参数打包成一个类似python元组的东西）</li>
<li><code>$*</code>把传入的参数看做一个整体的字符串。</li>
<li><code>$?</code>上一个命令退出情况，0为成功，非0为失败。</li>
<li><code>$$</code>当前脚本的进程数。</li>
</ul>
<p>一个求和脚本示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DATE<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>date <span style="color:#e6db74">&#34;+%Y-%m-%d&#34;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;PID: </span>$$<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Date: </span>$DATE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Script name: </span>$0<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;You&#39;ve entered </span>$#<span style="color:#e6db74"> params.&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ANS<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> PARAM in <span style="color:#e6db74">&#34;</span>$@<span style="color:#e6db74">&#34;</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  ANS<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>$ANS <span style="color:#f92672">+</span> PARAM<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;The sum is </span>$ANS<span style="color:#e6db74">.&#34;</span>
</span></span></code></pre></div><p>结果：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260130-1.png" alt=""></p>
<p>shell的for循环语法和python看起来似乎很相似。比如，你可以这么写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> name in Alice Bob Charlie; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Hello </span>$name<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>结果输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Hello Alice
</span></span><span style="display:flex;"><span>Hello Bob
</span></span><span style="display:flex;"><span>Hello Charlie
</span></span></code></pre></div><p>shell script中一个更强大的功能是通配符遍历。比如，如果你想罗列一个目录下的所有pdf文件，你可以这么写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> file in *.pdf; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;pdf </span>$count<span style="color:#e6db74">: </span>$file<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  count<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>$count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>效果：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260130-2.png" alt=""></p>
<p>如果你想使用C风格的数值循环，此处记录一下写法，不再实验。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>i<span style="color:#f92672">=</span>1; i&lt;<span style="color:#f92672">=</span>5; i++<span style="color:#f92672">))</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;次数: </span>$i<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>while循环的一般写法也就是if和for的杂交，也只是记录一下，不再实验。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $count -le <span style="color:#ae81ff">5</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Count: </span>$count<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">((</span>count++<span style="color:#f92672">))</span> <span style="color:#75715e"># Bash 中的自增写法</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><h3 id="插叙重定向与管道">插叙：重定向与管道<a href="#%e6%8f%92%e5%8f%99%e9%87%8d%e5%ae%9a%e5%90%91%e4%b8%8e%e7%ae%a1%e9%81%93" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h3>
<p>在linux命令中，<code>|</code>、<code>&gt;</code>、<code>&lt;</code>可以影响数据的流向，为我们编写脚本和日常使用指令提供了极大的方便。理解这些工具的秘诀在于想象数据像水一样流动。</p>
<p><code>&gt;</code>和<code>&gt;&gt;</code>表示<strong>输出重定向</strong>。它们可以把<strong>原本应该打印在屏幕上的内容</strong>存到指定的文件中。其中<code>&gt;</code>表示覆写，会清空原有内容；<code>&gt;&gt;</code>表示追加写，会在文件末尾接着写。</p>
<p>你应该这样理解：每一个指令都像一个有着通用的输入、输出管道的机器。默认情况下，输出的管道会直接连到你的终端上。现在，我们不希望它把数据直接流到屏幕上，而是流到文件里，所以我们接一个管道把指令输出的东西转移到文件中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Hello&#34;</span> &gt; hello.txt
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Helloworld&#34;</span> &gt;&gt; hello.txt
</span></span></code></pre></div><p>结果：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260130-3.png" alt=""></p>
<p>内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Hello
</span></span><span style="display:flex;"><span>Helloworld
</span></span></code></pre></div><p><code>echo</code>指令就像是一个只会接受东西输出东西的发射器，但是它也使用了通用的管道。</p>
<p>一个常见的应用是conda导出环境配置。此处就用到了输出重定向。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>conda env export &gt; environment.yml <span style="color:#75715e"># 导出环境</span>
</span></span></code></pre></div><p>此外，正常的输出<code>&gt;</code>实际是<code>1&gt;</code>的缩写。错误输出<code>2&gt;</code>和正常输出并不走同一个管道。这意味着有时即使你进行了<code>&gt;</code>的重定向，当出现错误时，报错信息还是会流到屏幕上。你需要对报错做额外的处理。</p>
<p>与之相对的，<code>&lt;</code>表示输入重定向。比如某些指令默认从屏幕读取输入，你就可以用<code>&lt;</code>来将默认的输入方式改为从指定的文件中输入。每次会自动读取一行。</p>
<p>举个例子，我们随便写一个若干行的随机人名文件。</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260130-4.png" alt=""></p>
<p>然后编写这样的测试脚本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FILE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$PWD<span style="color:#e6db74">/names.txt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> read name; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  echo $name
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span> &lt;$FILE
</span></span></code></pre></div><p>FILE定义了指定的文件，此处我们默认在names.txt目录下执行该脚本。假如你在一个没有names.txt的目录下执行该脚本，脚本就会报错。</p>
<p>运行效果：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260130-5.png" alt=""></p>
<p>符合预期。</p>
<p>然而，仅有输入输出重定向是不够的。它们只能代表数据加工开始和结束时数据的去向。但是假如数据加工的过程中也有多个步骤，仅仅使用输入输出重定向虽然也可以完成任务，但是免不了要用额外的存储空间缓存数据，并徒增写入和读取的用时。所以，我们为什么不能直接把一个指令的输出喂给另一个指令作为输入呢？</p>
<p>于是便有了管道符号<code>|</code>。它的作用就是把左边指令的输出喂给右边的指令作为输入。一些经典的用法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 1. 列出当前目录所有文件</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 把结果传给 grep，搜索包含 &#34;txt&#34; 的行</span>
</span></span><span style="display:flex;"><span>ls | grep <span style="color:#e6db74">&#34;txt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. 读取一个很长的文件内容</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 把内容传给 head，只看前 10 行</span>
</span></span><span style="display:flex;"><span>cat large_file.log | head -n <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. 查找所有正在运行的进程</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 搜索关于 &#34;python&#34; 的进程</span>
</span></span><span style="display:flex;"><span>ps aux | grep <span style="color:#e6db74">&#34;python&#34;</span>
</span></span></code></pre></div><h2 id="函数与递归">函数与递归<a href="#%e5%87%bd%e6%95%b0%e4%b8%8e%e9%80%92%e5%bd%92" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h2>
<p>虽然shell脚本看起来像是一堆指令堆在一起，但是实际上完全支持函数和递归调用。</p>
<p>一个简单的函数示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#66d9ef">$((</span>$1 <span style="color:#f92672">+</span> $2<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#66d9ef">$(</span>add $1 $2<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><p>输出结果：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260130-6.png" alt=""></p>
<p>shell函数相较于其他语言的函数有很大的行为差异。首先，shell script中的函数传参只能使用<code>$i</code>的形式读取第i个参数。此外，在shell中<code>return</code>关键字的用法是返回状态，只能返回0~255之间的整数，通常用0表示成功。而数据输出则使用echo，并在函数调用的时候使用<code>$(...)</code>符号捕获输出。这种设计的原因在于shell script本身是非常简陋的，想要返回数值唯一的方法就是把东西打印出来。</p>
<p><code>$(...)</code>符号在shell script中的行为和输出重定向很相似。它的功能就是把一个原本会输出到屏幕的输出重定向给变量。<code>$VAR</code>的写法则表示从变量的对应内存中提取数据。两者的功能是不同的。</p>
<p>shell script中定义的变量默认是全局变量，这和一般的程序语言的动态作用域有很大区别。如果我们希望一个变量只作用于函数体内部，我们必须要变量前添加<code>local</code>关键字。</p>
<p>shell script完全支持递归，以下是基于shell script的阶乘写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fact<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $1 -le <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    local prev<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>fact <span style="color:#66d9ef">$((</span>$1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#66d9ef">)))</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#66d9ef">$((</span>$prev <span style="color:#f92672">*</span> $1<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#66d9ef">$(</span>fact $1<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><p>输出结果：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260130-7.png" alt=""></p>
<p>一个基于shell script递归的文件树打印脚本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo_indent<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  local indent<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  local ans<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$2<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>i <span style="color:#f92672">=</span> 1; i &lt;<span style="color:#f92672">=</span> indent; i++<span style="color:#f92672">))</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    ans<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;    </span>$ans<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;</span>$ans<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>list_file_recursive<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  local dir<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  local indent<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$2<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> item in $dir/*; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -d <span style="color:#e6db74">&#34;</span>$item<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>      echo <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>echo_indent $indent <span style="color:#e6db74">&#34;Directory: </span>$item<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>      list_file_recursive <span style="color:#e6db74">&#34;</span>$item<span style="color:#e6db74">&#34;</span> <span style="color:#66d9ef">$((</span>$indent <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      echo <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>echo_indent $indent <span style="color:#e6db74">&#34;File: </span>$item<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>list_file_recursive $PWD <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>某次输出：</p>
<p><img src="/zh-cn/posts/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fshell%E8%84%9A%E6%9C%AC/%E5%B7%A5%E5%85%B7%E4%B8%8D%E5%9B%BE%E9%89%B404%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;shell%E8%84%9A%E6%9C%AC-20260130-8.png" alt=""></p>
<p>（下方lt为eza输出的文件树，可以当做标准答案。）</p>
<h1 id="总结">总结<a href="#%e6%80%bb%e7%bb%93" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path>
      <line x1="8" y1="12" x2="16" y2="12"></line>
   </svg></a></h1>
<p>虽然shell script的功能很多，但是写起来和正经的程序语言比还是有点折磨了。这边推荐把shell script当做python程序的包装器。</p>
<p>以下是我的博客发射器的包装器脚本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>set -e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PROJECT_ROOT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/python_projects/ControlCenter&#34;</span>
</span></span><span style="display:flex;"><span>VENV_ACTIVATE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$PROJECT_ROOT<span style="color:#e6db74">/venv/bin/activate&#34;</span>
</span></span><span style="display:flex;"><span>ENTRY_POINT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$PROJECT_ROOT<span style="color:#e6db74">/Entry.py&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -d <span style="color:#e6db74">&#34;</span>$PROJECT_ROOT<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;Error: Project directory not found at </span>$PROJECT_ROOT<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -f <span style="color:#e6db74">&#34;</span>$VENV_ACTIVATE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  source <span style="color:#e6db74">&#34;</span>$VENV_ACTIVATE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;Error: Virtual environment not found. Did you run &#39;python -m venv venv&#39;?&#34;</span>
</span></span><span style="display:flex;"><span>  exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>python <span style="color:#e6db74">&#34;</span>$ENTRY_POINT<span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">&#34;</span>$@<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>deactivate
</span></span></code></pre></div><p>功能是自动启动虚拟环境并运行python程序，同时自动传参执行指令。随后结束时自动关闭虚拟环境。至于具体的功能实现则交给代码更便于维护的python程序。</p>

			</div>
			<div class="human posts"><a href="https://brainmade.org/" target="_blank" rel="external noreferrer noopener"><abbr title="I don't hate AIs; but I love humans!"><svg fill="#fff" width="128" height="40" viewBox="0 0 128 40" xmlns="http://www.w3.org/2000/svg">
      <path
         d="M26.306 39.391H11.665a1.28 1.28 0 0 1-1.28-1.28v-3.838H6.399a1.28 1.28 0 0 1-1.28-1.28v-5.336l-4.41-2.198a1.28 1.28 0 0 1-.493-1.855l4.904-7.357v-2.175C5.12 6.298 11.422 0 19.194 0s14.073 6.3 14.075 14.071c-.316 13.912-5.38 11.758-5.59 17.023l-.093 7.018a1.3 1.3 0 0 1-.375.905 1.27 1.27 0 0 1-.905.375zm-13.361-2.559h12.082l.143-7.27c-.132-3.329 5.858-4.122 5.54-15.368-.179-6.356-5.157-11.635-11.515-11.635S7.68 7.713 7.679 14.071v2.559c-.001.253-.075.5-.215.71l-4.315 6.471 3.822 1.91a1.28 1.28 0 0 1 .708 1.145v4.848h3.987a1.28 1.28 0 0 1 1.28 1.28z" />
      <path
         d="M20.186 29.111v-9.644c.059 0 .118.009.177.009 4.885-.006 8.525-4.506 7.511-9.284a1.19 1.19 0 0 0-.911-.911 7.67 7.67 0 0 0-9.049 5.67l-.033-.036a7.66 7.66 0 0 0-7.03-2.085 1.19 1.19 0 0 0-.911.91c-1.014 4.777 2.627 9.277 7.51 9.284.118 0 .246-.014.369-.02v6.106zm1.419-16.072a5.33 5.33 0 0 1 4.062-1.553 5.33 5.33 0 0 1-5.614 5.615 5.3 5.3 0 0 1 1.552-4.061zm-7.904 6.057a5.3 5.3 0 0 1-1.559-4.061 5.323 5.323 0 0 1 5.614 5.615 5.3 5.3 0 0 1-4.055-1.554m38.419-6.79q0 2.346-1.567 3.63-1.567 1.282-4.351 1.283h-7.669V0h7.016q2.807 0 4.242 1.1 1.446 1.087 1.446 3.226 0 1.467-.729 2.481-.718 1.002-2.197 1.357 1.86.244 2.828 1.32.979 1.063.979 2.823zm-4.112-7.491q0-1.161-.663-1.65-.652-.488-1.947-.488h-3.655v4.265h3.677q1.36 0 1.968-.525.62-.537.62-1.601m.892 7.209q0-2.42-3.089-2.42h-4.069v4.938h4.188q1.545 0 2.252-.624.718-.635.718-1.894m16.26 5.194-3.557-6.538h-3.764v6.538H54.63V0h7.658q2.741 0 4.231 1.332 1.49 1.32 1.49 3.8 0 1.808-.913 3.128-.914 1.308-2.47 1.723l4.144 7.235zm-.381-11.94q0-2.481-2.828-2.481h-4.112v5.083h4.199q1.349 0 2.045-.684.696-.685.696-1.919m16.785 11.94-1.36-4.399h-5.841l-1.359 4.399h-3.209L75.386 0h3.785l5.569 17.219zM77.278 2.651l-.066.269q-.109.44-.261 1.002c-.152.563-.725 2.436-1.871 6.184h4.405l-1.512-4.949-.468-1.662zm9.551 14.567V0h3.209v17.219zm15.53 0L95.681 3.959q.196 1.931.196 3.104v10.155h-2.849V0h3.666l6.777 13.37q-.196-1.846-.196-3.361V0h2.85v17.219zM52.63 39.375V28.331q.011-.351.115-3.015-.818 3.257-1.209 4.541l-2.925 9.518h-2.418l-2.925-9.518-1.232-4.541q.139 2.809.139 3.717v10.342h-3.017V22.313h4.548l2.902 9.543.253.92.553 2.289.725-2.736 2.983-10.015h4.526v17.063zm17.64 0-1.44-4.359h-6.184l-1.44 4.359h-3.397l5.919-17.063h4.007l5.896 17.063zm-4.537-14.434-.069.267q-.115.436-.277.993c-.162.557-.767 2.414-1.98 6.128h4.663l-1.601-4.905-.495-1.647zm24.577 5.776q0 2.64-.99 4.614-.979 1.961-2.787 3.003-1.796 1.042-4.122 1.042h-6.564V22.313h5.873q4.099 0 6.345 2.18 2.245 2.167 2.245 6.224m-3.42 0q0-2.748-1.359-4.19-1.359-1.453-3.881-1.453h-2.407v11.54h2.879q2.188 0 3.478-1.586t1.29-4.311m6 8.659V22.313h12.759v2.761h-9.362v4.287h8.66v2.761h-8.66v4.492h9.835v2.761zm15.75 0v-3.693h3.328v3.693zm12.445-12.149q2.082 0 3.662.781 1.58.78 2.422 2.235.833 1.454.833 3.393 0 2.98-1.845 4.676Q124.302 40 121.085 40q-3.208 0-5.005-1.688-1.798-1.688-1.798-4.695c0-3.007.606-3.57 1.817-4.694q1.817-1.696 4.986-1.696m0 2.702q-2.157 0-3.378.97-1.23.97-1.23 2.72 0 1.777 1.22 2.747 1.211.97 3.388.97 2.195 0 3.462-.988 1.258-.997 1.258-2.711 0-1.778-1.23-2.738-1.23-.97-3.491-.97m6.725-13.402-5.062 2.935v3.107h5.062v2.648h-13.331v-6.322q0-2.261 1.031-3.491 1.022-1.23 2.942-1.23 1.4 0 2.422.754 1.012.754 1.334 2.038l5.601-3.42zm-9.244.314q-1.92 0-1.921 2.334v3.393h3.936v-3.465q0-1.113-.53-1.688t-1.486-.575m7.249-10.915a6.5 6.5 0 0 0-.313-2.002q-.321-.969-.814-1.499h-1.845v3.088h-2.063V0h4.901q1.088 1.005 1.703 2.622a9.4 9.4 0 0 1 .615 3.375q0 3.088-1.798 4.748-1.808 1.661-5.119 1.661-3.292 0-5.043-1.67-1.76-1.67-1.76-4.803 0-4.452 3.473-5.664l.776 2.442q-1.012.395-1.533 1.238-.52.844-.52 1.984 0 1.867 1.192 2.837t3.416.97q2.261 0 3.501-.997 1.23-1.005 1.23-2.818z" />
   </svg></abbr></a></div>

<div class="related-posts thin">
	<h2>See Also</h2>
	<ul>
	
	<li><a href="/zh-cn/posts/tui%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E6%96%B9%E6%A1%88/">TUI图像显示方案</a></li>
	
	<li><a href="/zh-cn/posts/%E6%A0%B8%E5%8A%A8%E5%8A%9B%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B0%84%E5%99%A8%E6%B5%8B%E8%AF%95/">核动力博客发射器测试</a></li>
	
	<li><a href="/zh-cn/posts/venvminiconda/">工具不图鉴03：虚拟环境&amp;conda</a></li>
	
	<li><a href="/zh-cn/posts/%E5%B9%B3%E6%9D%BF%E6%B8%B8%E6%88%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%A1%E5%88%924%E9%98%B6%E6%AE%B5/">平板游戏环境配置计划：4阶段</a></li>
	
	<li><a href="/zh-cn/posts/%E5%B9%B3%E6%9D%BF%E6%B8%B8%E6%88%8F%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E8%AE%A1%E5%88%92/">平板游戏环境部署计划</a></li>
	
	</ul>
</div>

		</article>
		<aside id="toc">
			<div class="toc-title">Table of Contents</div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#什么是变量">什么是“变量”？</a></li>
    <li><a href="#环境变量">环境变量</a>
      <ul>
        <li><a href="#一些常见的环境变量">一些常见的环境变量：</a></li>
        <li><a href="#如何让一个环境变量可以在所有shell进程中存在">如何让一个环境变量可以在所有shell进程中存在？</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#usrbinenv-bash">#!/usr/bin/env bash</a></li>
    <li><a href="#chmod-x-">chmod +x &hellip;</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#插叙重定向与管道">插叙：重定向与管道</a></li>
      </ul>
    </li>
    <li><a href="#函数与递归">函数与递归</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="http://localhost:1313/zh-cn/posts/d2l%E8%87%AA%E5%AD%A6%E6%97%A5%E5%BF%9703%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%8C%E7%BB%93/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left">
      <line x1="19" y1="12" x2="5" y2="12"></line>
      <polyline points="12 19 5 12 12 5"></polyline>
   </svg>&nbsp;Newer</span><br><span>D2L自学日志03：线性神经网络完结</span>
			</a>
			<a class="prev-post" href="http://localhost:1313/zh-cn/posts/tui%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E6%96%B9%E6%A1%88/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right">
      <line x1="5" y1="12" x2="19" y2="12"></line>
      <polyline points="12 5 19 12 12 19"></polyline>
   </svg></span><br><span>TUI图像显示方案</span>
			</a>
		</div>
		<div id="comments" class="thin"><script src="https://giscus.app/client.js"
        data-repo="Moonhalf383/Hermit-v2-blog-yorozumoon"
        data-repo-id="R_kgDOQaFILg"
        data-category="Announcements"
        data-category-id="DIC_kwDOQaFILs4CyFGz"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="transparent_dark"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
</div>
	</main>
<footer id="site-footer" class="section-inner thin animated fadeIn faster">
<p>
	&copy; 2026 <a href="http://localhost:1313/">Yorozumoon</a>
	&#183; copyright by Moonhalf
	&#183; Made with <a href="https://gohugo.io/" target="_blank" rel="noopener" title="The world's fastest framework for building websites">Hugo</a> &amp; <a href="https://github.com/1bl4z3r/hermit-V2" target="_blank" rel="noopener" title="A fast, minimalist Hugo theme">Hermit-V2</a>
	</p></footer>
<script async src="http://localhost:1313/js/bundle.min.a2910447d5c22e84c4b04382d8c10c056b2b9d3e15c64d1fa04882359d61afd3.js" integrity="sha256-opEER9XCLoTEsEOC2MEMBWsrnT4Vxk0foEiCNZ1hr9M=" crossorigin="anonymous"></script><script async src="http://localhost:1313/js/link-share.min.24409a4f6e5537d70ffc55ec8f9192208d718678cb8638585342423020b37f39.js" integrity="sha256-JECaT25VN9cP/FXsj5GSII1xhnjLhjhYU0JCMCCzfzk=" crossorigin="anonymous"></script><script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']]
    }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
